/*
  This file was generated by mcd2c.py
  It should not be edited by hand
*/

#include <stdlib.h>
#include <string.h>

#include "1_14_4_proto.h"

const char *handshaking_toserver_strings[] = {
  "handshaking_toserver_set_protocol",
  "handshaking_toserver_legacy_server_list_ping"
};

const char *status_toclient_strings[] = {
  "status_toclient_server_info",
  "status_toclient_ping"
};

const char *status_toserver_strings[] = {
  "status_toserver_ping_start",
  "status_toserver_ping"
};

const char *login_toclient_strings[] = {
  "login_toclient_disconnect",
  "login_toclient_encryption_begin",
  "login_toclient_success",
  "login_toclient_compress",
  "login_toclient_login_plugin_request"
};

const char *login_toserver_strings[] = {
  "login_toserver_login_start",
  "login_toserver_encryption_begin",
  "login_toserver_login_plugin_response"
};

const char *play_toclient_strings[] = {
  "play_toclient_spawn_entity",
  "play_toclient_spawn_entity_experience_orb",
  "play_toclient_spawn_entity_weather",
  "play_toclient_spawn_entity_living",
  "play_toclient_spawn_entity_painting",
  "play_toclient_named_entity_spawn",
  "play_toclient_animation",
  "play_toclient_statistics",
  "play_toclient_block_break_animation",
  "play_toclient_tile_entity_data",
  "play_toclient_block_action",
  "play_toclient_block_change",
  "play_toclient_boss_bar",
  "play_toclient_difficulty",
  "play_toclient_chat",
  "play_toclient_multi_block_change",
  "play_toclient_tab_complete",
  "play_toclient_declare_commands",
  "play_toclient_transaction",
  "play_toclient_close_window",
  "play_toclient_window_items",
  "play_toclient_craft_progress_bar",
  "play_toclient_set_slot",
  "play_toclient_set_cooldown",
  "play_toclient_custom_payload",
  "play_toclient_named_sound_effect",
  "play_toclient_kick_disconnect",
  "play_toclient_entity_status",
  "play_toclient_explosion",
  "play_toclient_unload_chunk",
  "play_toclient_game_state_change",
  "play_toclient_open_horse_window",
  "play_toclient_keep_alive",
  "play_toclient_map_chunk",
  "play_toclient_world_event",
  "play_toclient_world_particles",
  "play_toclient_update_light",
  "play_toclient_login",
  "play_toclient_map",
  "play_toclient_trade_list",
  "play_toclient_rel_entity_move",
  "play_toclient_entity_move_look",
  "play_toclient_entity_look",
  "play_toclient_entity",
  "play_toclient_vehicle_move",
  "play_toclient_open_book",
  "play_toclient_open_window",
  "play_toclient_open_sign_entity",
  "play_toclient_craft_recipe_response",
  "play_toclient_abilities",
  "play_toclient_combat_event",
  "play_toclient_player_info",
  "play_toclient_face_player",
  "play_toclient_position",
  "play_toclient_unlock_recipes",
  "play_toclient_entity_destroy",
  "play_toclient_remove_entity_effect",
  "play_toclient_resource_pack_send",
  "play_toclient_respawn",
  "play_toclient_entity_head_rotation",
  "play_toclient_select_advancement_tab",
  "play_toclient_world_border",
  "play_toclient_camera",
  "play_toclient_held_item_slot",
  "play_toclient_update_view_position",
  "play_toclient_update_view_distance",
  "play_toclient_scoreboard_display_objective",
  "play_toclient_entity_metadata",
  "play_toclient_attach_entity",
  "play_toclient_entity_velocity",
  "play_toclient_entity_equipment",
  "play_toclient_experience",
  "play_toclient_update_health",
  "play_toclient_scoreboard_objective",
  "play_toclient_set_passengers",
  "play_toclient_teams",
  "play_toclient_scoreboard_score",
  "play_toclient_spawn_position",
  "play_toclient_update_time",
  "play_toclient_title",
  "play_toclient_entity_sound_effect",
  "play_toclient_sound_effect",
  "play_toclient_stop_sound",
  "play_toclient_playerlist_header",
  "play_toclient_nbt_query_response",
  "play_toclient_collect",
  "play_toclient_entity_teleport",
  "play_toclient_advancements",
  "play_toclient_entity_update_attributes",
  "play_toclient_entity_effect",
  "play_toclient_declare_recipes",
  "play_toclient_tags",
  "play_toclient_acknowledge_player_digging"
};

const char *play_toserver_strings[] = {
  "play_toserver_teleport_confirm",
  "play_toserver_query_block_nbt",
  "play_toserver_set_difficulty",
  "play_toserver_chat",
  "play_toserver_client_command",
  "play_toserver_settings",
  "play_toserver_tab_complete",
  "play_toserver_transaction",
  "play_toserver_enchant_item",
  "play_toserver_window_click",
  "play_toserver_close_window",
  "play_toserver_custom_payload",
  "play_toserver_edit_book",
  "play_toserver_query_entity_nbt",
  "play_toserver_use_entity",
  "play_toserver_keep_alive",
  "play_toserver_lock_difficulty",
  "play_toserver_position",
  "play_toserver_position_look",
  "play_toserver_look",
  "play_toserver_flying",
  "play_toserver_vehicle_move",
  "play_toserver_steer_boat",
  "play_toserver_pick_item",
  "play_toserver_craft_recipe_request",
  "play_toserver_abilities",
  "play_toserver_block_dig",
  "play_toserver_entity_action",
  "play_toserver_steer_vehicle",
  "play_toserver_crafting_book_data",
  "play_toserver_name_item",
  "play_toserver_resource_pack_receive",
  "play_toserver_advancement_tab",
  "play_toserver_select_trade",
  "play_toserver_set_beacon_effect",
  "play_toserver_held_item_slot",
  "play_toserver_update_command_block",
  "play_toserver_update_command_block_minecart",
  "play_toserver_set_creative_slot",
  "play_toserver_update_jigsaw_block",
  "play_toserver_update_structure_block",
  "play_toserver_update_sign",
  "play_toserver_arm_animation",
  "play_toserver_spectate",
  "play_toserver_block_place",
  "play_toserver_use_item"
};

const char **protocol_strings[protocol_state_max][protocol_direction_max] = {
  [handshaking_id][toserver_id] = handshaking_toserver_strings,
  [status_id][toclient_id] = status_toclient_strings,
  [status_id][toserver_id] = status_toserver_strings,
  [login_id][toclient_id] = login_toclient_strings,
  [login_id][toserver_id] = login_toserver_strings,
  [play_id][toclient_id] = play_toclient_strings,
  [play_id][toserver_id] = play_toserver_strings
};

const int protocol_max_ids[protocol_state_max][protocol_direction_max] = {
  [handshaking_id][toclient_id] = handshaking_toclient_max,
  [handshaking_id][toserver_id] = handshaking_toserver_max,
  [status_id][toclient_id] = status_toclient_max,
  [status_id][toserver_id] = status_toserver_max,
  [login_id][toclient_id] = login_toclient_max,
  [login_id][toserver_id] = login_toserver_max,
  [play_id][toclient_id] = play_toclient_max,
  [play_id][toserver_id] = play_toserver_max
};

int walk_handshaking_toserver_set_protocol(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 2) {
    return -1;
  }
  size += 2;
  source += 2;
  max_len -= 2;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_handshaking_toserver_set_protocol(handshaking_toserver_set_protocol packet) {
  size_t size = 0;
  size += size_varlong(packet.protocol_version);
  size += size_string(packet.server_host);
  size += 2;
  size += size_varlong(packet.next_state);
  return size;
}

char * dec_handshaking_toserver_set_protocol(handshaking_toserver_set_protocol *packet, char * source) {
  source = dec_varlong(&packet->protocol_version, source);
  if(!(source = dec_string(&packet->server_host, source))) return NULL;
  source = dec_be16(&packet->server_port, source);
  source = dec_varlong(&packet->next_state, source);
  return source;
}

char * enc_handshaking_toserver_set_protocol(char * dest, handshaking_toserver_set_protocol source) {
  dest = enc_varlong(dest, source.protocol_version);
  dest = enc_string(dest, source.server_host);
  dest = enc_be16(dest, source.server_port);
  dest = enc_varlong(dest, source.next_state);
  return dest;
}

void free_handshaking_toserver_set_protocol(handshaking_toserver_set_protocol packet) {
  free_string(packet.server_host);
}

int walk_handshaking_toserver_legacy_server_list_ping(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_handshaking_toserver_legacy_server_list_ping(handshaking_toserver_legacy_server_list_ping packet) {
  return 1;
}

char * dec_handshaking_toserver_legacy_server_list_ping(handshaking_toserver_legacy_server_list_ping *packet, char * source) {
  source = dec_byte(&packet->payload, source);
  return source;
}

char * enc_handshaking_toserver_legacy_server_list_ping(char * dest, handshaking_toserver_legacy_server_list_ping source) {
  dest = enc_byte(dest, source.payload);
  return dest;
}

int walk_status_toclient_server_info(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_status_toclient_server_info(status_toclient_server_info packet) {
  size_t size = 0;
  size += size_string(packet.response);
  return size;
}

char * dec_status_toclient_server_info(status_toclient_server_info *packet, char * source) {
  if(!(source = dec_string(&packet->response, source))) return NULL;
  return source;
}

char * enc_status_toclient_server_info(char * dest, status_toclient_server_info source) {
  dest = enc_string(dest, source.response);
  return dest;
}

void free_status_toclient_server_info(status_toclient_server_info packet) {
  free_string(packet.response);
}

int walk_status_toclient_ping(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_status_toclient_ping(status_toclient_ping packet) {
  return 8;
}

char * dec_status_toclient_ping(status_toclient_ping *packet, char * source) {
  source = dec_be64(&packet->time, source);
  return source;
}

char * enc_status_toclient_ping(char * dest, status_toclient_ping source) {
  dest = enc_be64(dest, source.time);
  return dest;
}

int walk_status_toserver_ping(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_status_toserver_ping(status_toserver_ping packet) {
  return 8;
}

char * dec_status_toserver_ping(status_toserver_ping *packet, char * source) {
  source = dec_be64(&packet->time, source);
  return source;
}

char * enc_status_toserver_ping(char * dest, status_toserver_ping source) {
  dest = enc_be64(dest, source.time);
  return dest;
}

int walk_login_toclient_disconnect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_login_toclient_disconnect(login_toclient_disconnect packet) {
  size_t size = 0;
  size += size_string(packet.reason);
  return size;
}

char * dec_login_toclient_disconnect(login_toclient_disconnect *packet, char * source) {
  if(!(source = dec_string(&packet->reason, source))) return NULL;
  return source;
}

char * enc_login_toclient_disconnect(char * dest, login_toclient_disconnect source) {
  dest = enc_string(dest, source.reason);
  return dest;
}

void free_login_toclient_disconnect(login_toclient_disconnect packet) {
  free_string(packet.reason);
}

int walk_login_toclient_encryption_begin(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t public_key_len;
  source = dec_varlong(&public_key_len, source);
  if(max_len < public_key_len) {
    return -1;
  }
  size += public_key_len;
  source += public_key_len;
  max_len -= public_key_len;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t verify_token_len;
  source = dec_varlong(&verify_token_len, source);
  if(max_len < verify_token_len) {
    return -1;
  }
  size += verify_token_len;
  source += verify_token_len;
  max_len -= verify_token_len;
  return size;
}

size_t size_login_toclient_encryption_begin(login_toclient_encryption_begin packet) {
  size_t size = 0;
  size += size_string(packet.server_id);
  size += size_varlong(packet.public_key.len);
  size += packet.public_key.len;
  size += size_varlong(packet.verify_token.len);
  size += packet.verify_token.len;
  return size;
}

char * dec_login_toclient_encryption_begin(login_toclient_encryption_begin *packet, char * source) {
  if(!(source = dec_string(&packet->server_id, source))) return NULL;
  source = dec_varlong(&packet->public_key.len, source);
  if(!(packet->public_key.base = malloc(packet->public_key.len))) return NULL;
  memcpy(packet->public_key.base, source, packet->public_key.len);
  source += packet->public_key.len;
  source = dec_varlong(&packet->verify_token.len, source);
  if(!(packet->verify_token.base = malloc(packet->verify_token.len))) return NULL;
  memcpy(packet->verify_token.base, source, packet->verify_token.len);
  source += packet->verify_token.len;
  return source;
}

char * enc_login_toclient_encryption_begin(char * dest, login_toclient_encryption_begin source) {
  dest = enc_string(dest, source.server_id);
  dest = enc_varlong(dest, source.public_key.len);
  dest = memcpy(dest, source.public_key.base, source.public_key.len);
  dest = enc_varlong(dest, source.verify_token.len);
  dest = memcpy(dest, source.verify_token.base, source.verify_token.len);
  return dest;
}

void free_login_toclient_encryption_begin(login_toclient_encryption_begin packet) {
  free_string(packet.server_id);
  free(packet.public_key.base);
  free(packet.verify_token.base);
}

int walk_login_toclient_success(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_login_toclient_success(login_toclient_success packet) {
  size_t size = 0;
  size += size_string(packet.uuid);
  size += size_string(packet.username);
  return size;
}

char * dec_login_toclient_success(login_toclient_success *packet, char * source) {
  if(!(source = dec_string(&packet->uuid, source))) return NULL;
  if(!(source = dec_string(&packet->username, source))) return NULL;
  return source;
}

char * enc_login_toclient_success(char * dest, login_toclient_success source) {
  dest = enc_string(dest, source.uuid);
  dest = enc_string(dest, source.username);
  return dest;
}

void free_login_toclient_success(login_toclient_success packet) {
  free_string(packet.uuid);
  free_string(packet.username);
}

int walk_login_toclient_compress(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_login_toclient_compress(login_toclient_compress packet) {
  size_t size = 0;
  size += size_varlong(packet.threshold);
  return size;
}

char * dec_login_toclient_compress(login_toclient_compress *packet, char * source) {
  source = dec_varlong(&packet->threshold, source);
  return source;
}

char * enc_login_toclient_compress(char * dest, login_toclient_compress source) {
  dest = enc_varlong(dest, source.threshold);
  return dest;
}

int walk_login_toclient_login_plugin_request(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t data_len;
  source = dec_varlong(&data_len, source);
  if(max_len < data_len) {
    return -1;
  }
  size += data_len;
  source += data_len;
  max_len -= data_len;
  return size;
}

size_t size_login_toclient_login_plugin_request(login_toclient_login_plugin_request packet) {
  size_t size = 0;
  size += size_varlong(packet.message_id);
  size += size_string(packet.channel);
  size += size_varlong(packet.data.len);
  size += packet.data.len;
  return size;
}

char * dec_login_toclient_login_plugin_request(login_toclient_login_plugin_request *packet, char * source) {
  source = dec_varlong(&packet->message_id, source);
  if(!(source = dec_string(&packet->channel, source))) return NULL;
  source = dec_varlong(&packet->data.len, source);
  if(!(packet->data.base = malloc(packet->data.len))) return NULL;
  memcpy(packet->data.base, source, packet->data.len);
  source += packet->data.len;
  return source;
}

char * enc_login_toclient_login_plugin_request(char * dest, login_toclient_login_plugin_request source) {
  dest = enc_varlong(dest, source.message_id);
  dest = enc_string(dest, source.channel);
  dest = enc_varlong(dest, source.data.len);
  dest = memcpy(dest, source.data.base, source.data.len);
  return dest;
}

void free_login_toclient_login_plugin_request(login_toclient_login_plugin_request packet) {
  free_string(packet.channel);
  free(packet.data.base);
}

int walk_login_toserver_login_start(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_login_toserver_login_start(login_toserver_login_start packet) {
  size_t size = 0;
  size += size_string(packet.username);
  return size;
}

char * dec_login_toserver_login_start(login_toserver_login_start *packet, char * source) {
  if(!(source = dec_string(&packet->username, source))) return NULL;
  return source;
}

char * enc_login_toserver_login_start(char * dest, login_toserver_login_start source) {
  dest = enc_string(dest, source.username);
  return dest;
}

void free_login_toserver_login_start(login_toserver_login_start packet) {
  free_string(packet.username);
}

int walk_login_toserver_encryption_begin(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t shared_secret_len;
  source = dec_varlong(&shared_secret_len, source);
  if(max_len < shared_secret_len) {
    return -1;
  }
  size += shared_secret_len;
  source += shared_secret_len;
  max_len -= shared_secret_len;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t verify_token_len;
  source = dec_varlong(&verify_token_len, source);
  if(max_len < verify_token_len) {
    return -1;
  }
  size += verify_token_len;
  source += verify_token_len;
  max_len -= verify_token_len;
  return size;
}

size_t size_login_toserver_encryption_begin(login_toserver_encryption_begin packet) {
  size_t size = 0;
  size += size_varlong(packet.shared_secret.len);
  size += packet.shared_secret.len;
  size += size_varlong(packet.verify_token.len);
  size += packet.verify_token.len;
  return size;
}

char * dec_login_toserver_encryption_begin(login_toserver_encryption_begin *packet, char * source) {
  source = dec_varlong(&packet->shared_secret.len, source);
  if(!(packet->shared_secret.base = malloc(packet->shared_secret.len))) return NULL;
  memcpy(packet->shared_secret.base, source, packet->shared_secret.len);
  source += packet->shared_secret.len;
  source = dec_varlong(&packet->verify_token.len, source);
  if(!(packet->verify_token.base = malloc(packet->verify_token.len))) return NULL;
  memcpy(packet->verify_token.base, source, packet->verify_token.len);
  source += packet->verify_token.len;
  return source;
}

char * enc_login_toserver_encryption_begin(char * dest, login_toserver_encryption_begin source) {
  dest = enc_varlong(dest, source.shared_secret.len);
  dest = memcpy(dest, source.shared_secret.base, source.shared_secret.len);
  dest = enc_varlong(dest, source.verify_token.len);
  dest = memcpy(dest, source.verify_token.base, source.verify_token.len);
  return dest;
}

void free_login_toserver_encryption_begin(login_toserver_encryption_begin packet) {
  free(packet.shared_secret.base);
  free(packet.verify_token.base);
}

int walk_login_toserver_login_plugin_response(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t data_len;
  source = dec_varlong(&data_len, source);
  if(max_len < data_len) {
    return -1;
  }
  size += data_len;
  source += data_len;
  max_len -= data_len;
  return size;
}

size_t size_login_toserver_login_plugin_response(login_toserver_login_plugin_response packet) {
  size_t size = 0;
  size += size_varlong(packet.message_id);
  size += 1;
  size += size_varlong(packet.data.len);
  size += packet.data.len;
  return size;
}

char * dec_login_toserver_login_plugin_response(login_toserver_login_plugin_response *packet, char * source) {
  source = dec_varlong(&packet->message_id, source);
  source = dec_byte(&packet->success, source);
  source = dec_varlong(&packet->data.len, source);
  if(!(packet->data.base = malloc(packet->data.len))) return NULL;
  memcpy(packet->data.base, source, packet->data.len);
  source += packet->data.len;
  return source;
}

char * enc_login_toserver_login_plugin_response(char * dest, login_toserver_login_plugin_response source) {
  dest = enc_varlong(dest, source.message_id);
  dest = enc_byte(dest, source.success);
  dest = enc_varlong(dest, source.data.len);
  dest = memcpy(dest, source.data.base, source.data.len);
  return dest;
}

void free_login_toserver_login_plugin_response(login_toserver_login_plugin_response packet) {
  free(packet.data.base);
}

int walk_play_toclient_spawn_entity(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 16) {
    return -1;
  }
  size += 16;
  source += 16;
  max_len -= 16;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 36) {
    return -1;
  }
  return size + 36;
}

size_t size_play_toclient_spawn_entity(play_toclient_spawn_entity packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 16;
  size += size_varlong(packet.type);
  return size + 36;
}

char * dec_play_toclient_spawn_entity(play_toclient_spawn_entity *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_uuid(&packet->object_uuid, source);
  source = dec_varlong(&packet->type, source);
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_be32(&packet->object_data, source);
  source = dec_be16(&packet->velocity_x, source);
  source = dec_be16(&packet->velocity_y, source);
  source = dec_be16(&packet->velocity_z, source);
  return source;
}

char * enc_play_toclient_spawn_entity(char * dest, play_toclient_spawn_entity source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_uuid(dest, source.object_uuid);
  dest = enc_varlong(dest, source.type);
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_byte(dest, source.pitch);
  dest = enc_byte(dest, source.yaw);
  dest = enc_be32(dest, source.object_data);
  dest = enc_be16(dest, source.velocity_x);
  dest = enc_be16(dest, source.velocity_y);
  dest = enc_be16(dest, source.velocity_z);
  return dest;
}

int walk_play_toclient_spawn_entity_experience_orb(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 26) {
    return -1;
  }
  return size + 26;
}

size_t size_play_toclient_spawn_entity_experience_orb(play_toclient_spawn_entity_experience_orb packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 26;
}

char * dec_play_toclient_spawn_entity_experience_orb(play_toclient_spawn_entity_experience_orb *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_be16(&packet->count, source);
  return source;
}

char * enc_play_toclient_spawn_entity_experience_orb(char * dest, play_toclient_spawn_entity_experience_orb source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_be16(dest, source.count);
  return dest;
}

int walk_play_toclient_spawn_entity_weather(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 25) {
    return -1;
  }
  return size + 25;
}

size_t size_play_toclient_spawn_entity_weather(play_toclient_spawn_entity_weather packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 25;
}

char * dec_play_toclient_spawn_entity_weather(play_toclient_spawn_entity_weather *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->type, source);
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  return source;
}

char * enc_play_toclient_spawn_entity_weather(char * dest, play_toclient_spawn_entity_weather source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.type);
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  return dest;
}

int walk_play_toclient_spawn_entity_living(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 16) {
    return -1;
  }
  size += 16;
  source += 16;
  max_len -= 16;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 33) {
    return -1;
  }
  size += 33;
  source += 33;
  max_len -= 33;
  if((ret = walk_metadata(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_spawn_entity_living(play_toclient_spawn_entity_living packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 16;
  size += size_varlong(packet.type);
  size += 33;
  size += size_metadata(packet.metadata);
  return size;
}

char * dec_play_toclient_spawn_entity_living(play_toclient_spawn_entity_living *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_uuid(&packet->entity_uuid, source);
  source = dec_varlong(&packet->type, source);
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_byte(&packet->head_pitch, source);
  source = dec_be16(&packet->velocity_x, source);
  source = dec_be16(&packet->velocity_y, source);
  source = dec_be16(&packet->velocity_z, source);
  if(!(source = dec_metadata(&packet->metadata, source))) return NULL;
  return source;
}

char * enc_play_toclient_spawn_entity_living(char * dest, play_toclient_spawn_entity_living source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_uuid(dest, source.entity_uuid);
  dest = enc_varlong(dest, source.type);
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_byte(dest, source.yaw);
  dest = enc_byte(dest, source.pitch);
  dest = enc_byte(dest, source.head_pitch);
  dest = enc_be16(dest, source.velocity_x);
  dest = enc_be16(dest, source.velocity_y);
  dest = enc_be16(dest, source.velocity_z);
  dest = enc_metadata(dest, source.metadata);
  return dest;
}

void free_play_toclient_spawn_entity_living(play_toclient_spawn_entity_living packet) {
  free_metadata(packet.metadata);
}

int walk_play_toclient_spawn_entity_painting(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 16) {
    return -1;
  }
  size += 16;
  source += 16;
  max_len -= 16;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 9) {
    return -1;
  }
  return size + 9;
}

size_t size_play_toclient_spawn_entity_painting(play_toclient_spawn_entity_painting packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 16;
  size += size_varlong(packet.title);
  return size + 9;
}

char * dec_play_toclient_spawn_entity_painting(play_toclient_spawn_entity_painting *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_uuid(&packet->entity_uuid, source);
  source = dec_varlong(&packet->title, source);
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->direction, source);
  return source;
}

char * enc_play_toclient_spawn_entity_painting(char * dest, play_toclient_spawn_entity_painting source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_uuid(dest, source.entity_uuid);
  dest = enc_varlong(dest, source.title);
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.direction);
  return dest;
}

int walk_play_toclient_named_entity_spawn(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 42) {
    return -1;
  }
  size += 42;
  source += 42;
  max_len -= 42;
  if((ret = walk_metadata(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_named_entity_spawn(play_toclient_named_entity_spawn packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 42;
  size += size_metadata(packet.metadata);
  return size;
}

char * dec_play_toclient_named_entity_spawn(play_toclient_named_entity_spawn *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_uuid(&packet->player_uuid, source);
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_byte(&packet->pitch, source);
  if(!(source = dec_metadata(&packet->metadata, source))) return NULL;
  return source;
}

char * enc_play_toclient_named_entity_spawn(char * dest, play_toclient_named_entity_spawn source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_uuid(dest, source.player_uuid);
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_byte(dest, source.yaw);
  dest = enc_byte(dest, source.pitch);
  dest = enc_metadata(dest, source.metadata);
  return dest;
}

void free_play_toclient_named_entity_spawn(play_toclient_named_entity_spawn packet) {
  free_metadata(packet.metadata);
}

int walk_play_toclient_animation(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_animation(play_toclient_animation packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 1;
}

char * dec_play_toclient_animation(play_toclient_animation *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->animation, source);
  return source;
}

char * enc_play_toclient_animation(char * dest, play_toclient_animation source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.animation);
  return dest;
}

int walk_play_toclient_statistics(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t entries_count;
  source = dec_varlong(&entries_count, source);
  for(size_t i_0 = 0; i_0 < entries_count; ++i_0) {
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_statistics(play_toclient_statistics packet) {
  size_t size = 0;
  size += size_varlong(packet.entries.count);
  for(size_t i_0 = 0; i_0 < packet.entries.count; ++i_0) {
    size += size_varlong(packet.entries.base[i_0].category_id);
    size += size_varlong(packet.entries.base[i_0].statistic_id);
    size += size_varlong(packet.entries.base[i_0].value);
  }
  return size;
}

char * dec_play_toclient_statistics(play_toclient_statistics *packet, char * source) {
  source = dec_varlong(&packet->entries.count, source);
  if(!(packet->entries.base = malloc(sizeof(*packet->entries.base) * packet->entries.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->entries.count; ++i_0) {
    source = dec_varlong(&packet->entries.base[i_0].category_id, source);
    source = dec_varlong(&packet->entries.base[i_0].statistic_id, source);
    source = dec_varlong(&packet->entries.base[i_0].value, source);
  }
  return source;
}

char * enc_play_toclient_statistics(char * dest, play_toclient_statistics source) {
  dest = enc_varlong(dest, source.entries.count);
  for(size_t i_0 = 0; i_0 < source.entries.count; ++i_0) {
    dest = enc_varlong(dest, source.entries.base[i_0].category_id);
    dest = enc_varlong(dest, source.entries.base[i_0].statistic_id);
    dest = enc_varlong(dest, source.entries.base[i_0].value);
  }
  return dest;
}

void free_play_toclient_statistics(play_toclient_statistics packet) {
  free(packet.entries.base);
}

int walk_play_toclient_advancements(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t advancement_mapping_count;
  source = dec_varlong(&advancement_mapping_count, source);
  for(size_t i_0 = 0; i_0 < advancement_mapping_count; ++i_0) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if(max_len < 1) {
        return -1;
    }
    uint8_t parent_id_opt;
    source = dec_byte(&parent_id_opt, source);
    size += 1;
    max_len -= 1;
    if(parent_id_opt) {
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    }
    if(max_len < 1) {
      return -1;
    }
    uint8_t display_data_opt;
    source = dec_byte(&display_data_opt, source);
    size += 1;
    max_len -= 1;
    if(display_data_opt) {
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      if((ret = walk_slot(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      if(max_len < 4) {
        return -1;
      }
      uint32_t flags;
      size += 4;
      max_len -= 4;
      source = dec_be32(&flags, source);
      uint8_t has_background_texture = (flags>>0)&1;
      if(has_background_texture) {
        if((ret = walk_string(source, max_len)) < 0) {
        return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
      }
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
    }
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    max_len -= ret;
    int64_t criteria_count;
    source = dec_varlong(&criteria_count, source);
    for(size_t i_3 = 0; i_3 < criteria_count; ++i_3) {
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    }
    if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
    }
    size += ret;
    max_len -= ret;
    int64_t requirements_count;
    source = dec_varlong(&requirements_count, source);
    for(size_t i_3 = 0; i_3 < requirements_count; ++i_3) {
      if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
      }
      size += ret;
      max_len -= ret;
      int64_t requirements0_count;
      source = dec_varlong(&requirements0_count, source);
      for(size_t i_4 = 0; i_4 < requirements0_count; ++i_4) {
        if((ret = walk_string(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
      }
    }
  }
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t identifiers_count;
  source = dec_varlong(&identifiers_count, source);
  for(size_t i_0 = 0; i_0 < identifiers_count; ++i_0) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t progress_mapping_count;
  source = dec_varlong(&progress_mapping_count, source);
  for(size_t i_0 = 0; i_0 < progress_mapping_count; ++i_0) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    max_len -= ret;
    int64_t value_count;
    source = dec_varlong(&value_count, source);
    for(size_t i_2 = 0; i_2 < value_count; ++i_2) {
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      if(max_len < 1) {
          return -1;
      }
      uint8_t criterion_progress_opt;
      source = dec_byte(&criterion_progress_opt, source);
      size += 1;
      max_len -= 1;
      if(criterion_progress_opt) {
        if(max_len < 8) {
          return -1;
        }
        size += 8;
        source += 8;
        max_len -= 8;
      }
    }
  }
  return size;
}

size_t size_play_toclient_advancements(play_toclient_advancements packet) {
  size_t size = 0;
  size += 1;
  size += size_varlong(packet.advancement_mapping.count);
  for(size_t i_0 = 0; i_0 < packet.advancement_mapping.count; ++i_0) {
    size += size_string(packet.advancement_mapping.base[i_0].key);
    size += 1;
    if(packet.advancement_mapping.base[i_0].value.parent_id.opt) {
      size += size_string(packet.advancement_mapping.base[i_0].value.parent_id.val);
    }
    size += 1;
    if(packet.advancement_mapping.base[i_0].value.display_data.opt) {
      size += size_string(packet.advancement_mapping.base[i_0].value.display_data.val.title);
      size += size_string(packet.advancement_mapping.base[i_0].value.display_data.val.description);
      size += size_slot(packet.advancement_mapping.base[i_0].value.display_data.val.icon);
      size += size_varlong(packet.advancement_mapping.base[i_0].value.display_data.val.frame_type);
      size += 4;
      if(packet.advancement_mapping.base[i_0].value.display_data.val.flags.has_background_texture) {
        size += size_string(packet.advancement_mapping.base[i_0].value.display_data.val.background_texture);
      }
      size += 8;
    }
    size += size_varlong(packet.advancement_mapping.base[i_0].value.criteria.count);
    for(size_t i_3 = 0; i_3 < packet.advancement_mapping.base[i_0].value.criteria.count; ++i_3) {
      size += size_string(packet.advancement_mapping.base[i_0].value.criteria.base[i_3].key);
    }
    size += size_varlong(packet.advancement_mapping.base[i_0].value.requirements.count);
    for(size_t i_3 = 0; i_3 < packet.advancement_mapping.base[i_0].value.requirements.count; ++i_3) {
      size += size_varlong(packet.advancement_mapping.base[i_0].value.requirements.base[i_3].count);
      for(size_t i_4 = 0; i_4 < packet.advancement_mapping.base[i_0].value.requirements.base[i_3].count; ++i_4) {
        size += size_string(packet.advancement_mapping.base[i_0].value.requirements.base[i_3].base[i_4]);
      }
    }
  }
  size += size_varlong(packet.identifiers.count);
  for(size_t i_0 = 0; i_0 < packet.identifiers.count; ++i_0) {
    size += size_string(packet.identifiers.base[i_0]);
  }
  size += size_varlong(packet.progress_mapping.count);
  for(size_t i_0 = 0; i_0 < packet.progress_mapping.count; ++i_0) {
    size += size_string(packet.progress_mapping.base[i_0].key);
    size += size_varlong(packet.progress_mapping.base[i_0].value.count);
    for(size_t i_2 = 0; i_2 < packet.progress_mapping.base[i_0].value.count; ++i_2) {
      size += size_string(packet.progress_mapping.base[i_0].value.base[i_2].criterion_identifier);
      size += 1;
      if(packet.progress_mapping.base[i_0].value.base[i_2].criterion_progress.opt) {
        size += 8;
      }
    }
  }
  return size;
}

char * dec_play_toclient_advancements(play_toclient_advancements *packet, char * source) {
  source = dec_byte(&packet->reset, source);
  source = dec_varlong(&packet->advancement_mapping.count, source);
  if(!(packet->advancement_mapping.base = malloc(sizeof(*packet->advancement_mapping.base) * packet->advancement_mapping.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->advancement_mapping.count; ++i_0) {
    if(!(source = dec_string(&packet->advancement_mapping.base[i_0].key, source))) return NULL;
    source = dec_byte(&packet->advancement_mapping.base[i_0].value.parent_id.opt, source);
    if(packet->advancement_mapping.base[i_0].value.parent_id.opt) {
      if(!(source = dec_string(&packet->advancement_mapping.base[i_0].value.parent_id.val, source))) return NULL;
    }
    source = dec_byte(&packet->advancement_mapping.base[i_0].value.display_data.opt, source);
    if(packet->advancement_mapping.base[i_0].value.display_data.opt) {
      if(!(source = dec_string(&packet->advancement_mapping.base[i_0].value.display_data.val.title, source))) return NULL;
      if(!(source = dec_string(&packet->advancement_mapping.base[i_0].value.display_data.val.description, source))) return NULL;
      if(!(source = dec_slot(&packet->advancement_mapping.base[i_0].value.display_data.val.icon, source))) return NULL;
      source = dec_varlong(&packet->advancement_mapping.base[i_0].value.display_data.val.frame_type, source);
      uint32_t flags;
      source = dec_be32(&flags, source);
      packet->advancement_mapping.base[i_0].value.display_data.val.flags.hidden = (flags>>2)&1;
      packet->advancement_mapping.base[i_0].value.display_data.val.flags.show_toast = (flags>>1)&1;
      packet->advancement_mapping.base[i_0].value.display_data.val.flags.has_background_texture = (flags>>0)&1;
      if(packet->advancement_mapping.base[i_0].value.display_data.val.flags.has_background_texture) {
        if(!(source = dec_string(&packet->advancement_mapping.base[i_0].value.display_data.val.background_texture, source))) return NULL;
      }
      source = dec_bef32(&packet->advancement_mapping.base[i_0].value.display_data.val.x_cord, source);
      source = dec_bef32(&packet->advancement_mapping.base[i_0].value.display_data.val.y_cord, source);
    }
    source = dec_varlong(&packet->advancement_mapping.base[i_0].value.criteria.count, source);
    if(!(packet->advancement_mapping.base[i_0].value.criteria.base = malloc(sizeof(*packet->advancement_mapping.base[i_0].value.criteria.base) * packet->advancement_mapping.base[i_0].value.criteria.count))) return NULL;
    for(size_t i_3 = 0; i_3 < packet->advancement_mapping.base[i_0].value.criteria.count; ++i_3) {
      if(!(source = dec_string(&packet->advancement_mapping.base[i_0].value.criteria.base[i_3].key, source))) return NULL;
      // 'value' is a void type
    }
    source = dec_varlong(&packet->advancement_mapping.base[i_0].value.requirements.count, source);
    if(!(packet->advancement_mapping.base[i_0].value.requirements.base = malloc(sizeof(*packet->advancement_mapping.base[i_0].value.requirements.base) * packet->advancement_mapping.base[i_0].value.requirements.count))) return NULL;
    for(size_t i_3 = 0; i_3 < packet->advancement_mapping.base[i_0].value.requirements.count; ++i_3) {
      source = dec_varlong(&packet->advancement_mapping.base[i_0].value.requirements.base[i_3].count, source);
      if(!(packet->advancement_mapping.base[i_0].value.requirements.base[i_3].base = malloc(sizeof(*packet->advancement_mapping.base[i_0].value.requirements.base[i_3].base) * packet->advancement_mapping.base[i_0].value.requirements.base[i_3].count))) return NULL;
      for(size_t i_4 = 0; i_4 < packet->advancement_mapping.base[i_0].value.requirements.base[i_3].count; ++i_4) {
        if(!(source = dec_string(&packet->advancement_mapping.base[i_0].value.requirements.base[i_3].base[i_4], source))) return NULL;
      }
    }
  }
  source = dec_varlong(&packet->identifiers.count, source);
  if(!(packet->identifiers.base = malloc(sizeof(*packet->identifiers.base) * packet->identifiers.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->identifiers.count; ++i_0) {
    if(!(source = dec_string(&packet->identifiers.base[i_0], source))) return NULL;
  }
  source = dec_varlong(&packet->progress_mapping.count, source);
  if(!(packet->progress_mapping.base = malloc(sizeof(*packet->progress_mapping.base) * packet->progress_mapping.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->progress_mapping.count; ++i_0) {
    if(!(source = dec_string(&packet->progress_mapping.base[i_0].key, source))) return NULL;
    source = dec_varlong(&packet->progress_mapping.base[i_0].value.count, source);
    if(!(packet->progress_mapping.base[i_0].value.base = malloc(sizeof(*packet->progress_mapping.base[i_0].value.base) * packet->progress_mapping.base[i_0].value.count))) return NULL;
    for(size_t i_2 = 0; i_2 < packet->progress_mapping.base[i_0].value.count; ++i_2) {
      if(!(source = dec_string(&packet->progress_mapping.base[i_0].value.base[i_2].criterion_identifier, source))) return NULL;
      source = dec_byte(&packet->progress_mapping.base[i_0].value.base[i_2].criterion_progress.opt, source);
      if(packet->progress_mapping.base[i_0].value.base[i_2].criterion_progress.opt) {
        source = dec_be64(&packet->progress_mapping.base[i_0].value.base[i_2].criterion_progress.val, source);
      }
    }
  }
  return source;
}

char * enc_play_toclient_advancements(char * dest, play_toclient_advancements source) {
  dest = enc_byte(dest, source.reset);
  dest = enc_varlong(dest, source.advancement_mapping.count);
  for(size_t i_0 = 0; i_0 < source.advancement_mapping.count; ++i_0) {
    dest = enc_string(dest, source.advancement_mapping.base[i_0].key);
    dest = enc_byte(dest, source.advancement_mapping.base[i_0].value.parent_id.opt);
    if(source.advancement_mapping.base[i_0].value.parent_id.opt) {
      dest = enc_string(dest, source.advancement_mapping.base[i_0].value.parent_id.val);
    }
    dest = enc_byte(dest, source.advancement_mapping.base[i_0].value.display_data.opt);
    if(source.advancement_mapping.base[i_0].value.display_data.opt) {
      dest = enc_string(dest, source.advancement_mapping.base[i_0].value.display_data.val.title);
      dest = enc_string(dest, source.advancement_mapping.base[i_0].value.display_data.val.description);
      dest = enc_slot(dest, source.advancement_mapping.base[i_0].value.display_data.val.icon);
      dest = enc_varlong(dest, source.advancement_mapping.base[i_0].value.display_data.val.frame_type);
      uint32_t flags = 0;
      flags |= (source.advancement_mapping.base[i_0].value.display_data.val.flags.hidden&1)<<2;
      flags |= (source.advancement_mapping.base[i_0].value.display_data.val.flags.show_toast&1)<<1;
      flags |= (source.advancement_mapping.base[i_0].value.display_data.val.flags.has_background_texture&1)<<0;
      dest = enc_be32(dest, flags);
      if(source.advancement_mapping.base[i_0].value.display_data.val.flags.has_background_texture) {
        dest = enc_string(dest, source.advancement_mapping.base[i_0].value.display_data.val.background_texture);
      }
      dest = enc_bef32(dest, source.advancement_mapping.base[i_0].value.display_data.val.x_cord);
      dest = enc_bef32(dest, source.advancement_mapping.base[i_0].value.display_data.val.y_cord);
    }
    dest = enc_varlong(dest, source.advancement_mapping.base[i_0].value.criteria.count);
    for(size_t i_3 = 0; i_3 < source.advancement_mapping.base[i_0].value.criteria.count; ++i_3) {
      dest = enc_string(dest, source.advancement_mapping.base[i_0].value.criteria.base[i_3].key);
      // 'value' is a void type
    }
    dest = enc_varlong(dest, source.advancement_mapping.base[i_0].value.requirements.count);
    for(size_t i_3 = 0; i_3 < source.advancement_mapping.base[i_0].value.requirements.count; ++i_3) {
      dest = enc_varlong(dest, source.advancement_mapping.base[i_0].value.requirements.base[i_3].count);
      for(size_t i_4 = 0; i_4 < source.advancement_mapping.base[i_0].value.requirements.base[i_3].count; ++i_4) {
        dest = enc_string(dest, source.advancement_mapping.base[i_0].value.requirements.base[i_3].base[i_4]);
      }
    }
  }
  dest = enc_varlong(dest, source.identifiers.count);
  for(size_t i_0 = 0; i_0 < source.identifiers.count; ++i_0) {
    dest = enc_string(dest, source.identifiers.base[i_0]);
  }
  dest = enc_varlong(dest, source.progress_mapping.count);
  for(size_t i_0 = 0; i_0 < source.progress_mapping.count; ++i_0) {
    dest = enc_string(dest, source.progress_mapping.base[i_0].key);
    dest = enc_varlong(dest, source.progress_mapping.base[i_0].value.count);
    for(size_t i_2 = 0; i_2 < source.progress_mapping.base[i_0].value.count; ++i_2) {
      dest = enc_string(dest, source.progress_mapping.base[i_0].value.base[i_2].criterion_identifier);
      dest = enc_byte(dest, source.progress_mapping.base[i_0].value.base[i_2].criterion_progress.opt);
      if(source.progress_mapping.base[i_0].value.base[i_2].criterion_progress.opt) {
        dest = enc_be64(dest, source.progress_mapping.base[i_0].value.base[i_2].criterion_progress.val);
      }
    }
  }
  return dest;
}

void free_play_toclient_advancements(play_toclient_advancements packet) {
  for(size_t i_0 = 0; i_0 < packet.advancement_mapping.count; ++i_0) {
    free_string(packet.advancement_mapping.base[i_0].key);
    if(packet.advancement_mapping.base[i_0].value.parent_id.opt) {
      free_string(packet.advancement_mapping.base[i_0].value.parent_id.val);
    }
    if(packet.advancement_mapping.base[i_0].value.display_data.opt) {
      free_string(packet.advancement_mapping.base[i_0].value.display_data.val.title);
      free_string(packet.advancement_mapping.base[i_0].value.display_data.val.description);
      free_slot(packet.advancement_mapping.base[i_0].value.display_data.val.icon);
      if(packet.advancement_mapping.base[i_0].value.display_data.val.flags.has_background_texture) {
        free_string(packet.advancement_mapping.base[i_0].value.display_data.val.background_texture);
      }
    }
    for(size_t i_3 = 0; i_3 < packet.advancement_mapping.base[i_0].value.criteria.count; ++i_3) {
      free_string(packet.advancement_mapping.base[i_0].value.criteria.base[i_3].key);
    }
    free(packet.advancement_mapping.base[i_0].value.criteria.base);
    for(size_t i_3 = 0; i_3 < packet.advancement_mapping.base[i_0].value.requirements.count; ++i_3) {
      for(size_t i_4 = 0; i_4 < packet.advancement_mapping.base[i_0].value.requirements.base[i_3].count; ++i_4) {
        free_string(packet.advancement_mapping.base[i_0].value.requirements.base[i_3].base[i_4]);
      }
      free(packet.advancement_mapping.base[i_0].value.requirements.base[i_3].base);
    }
    free(packet.advancement_mapping.base[i_0].value.requirements.base);
  }
  free(packet.advancement_mapping.base);
  for(size_t i_0 = 0; i_0 < packet.identifiers.count; ++i_0) {
    free_string(packet.identifiers.base[i_0]);
  }
  free(packet.identifiers.base);
  for(size_t i_0 = 0; i_0 < packet.progress_mapping.count; ++i_0) {
    free_string(packet.progress_mapping.base[i_0].key);
    for(size_t i_2 = 0; i_2 < packet.progress_mapping.base[i_0].value.count; ++i_2) {
      free_string(packet.progress_mapping.base[i_0].value.base[i_2].criterion_identifier);
    }
    free(packet.progress_mapping.base[i_0].value.base);
  }
  free(packet.progress_mapping.base);
}

int walk_play_toclient_block_break_animation(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 9) {
    return -1;
  }
  return size + 9;
}

size_t size_play_toclient_block_break_animation(play_toclient_block_break_animation packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 9;
}

char * dec_play_toclient_block_break_animation(play_toclient_block_break_animation *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->destroy_stage, source);
  return source;
}

char * enc_play_toclient_block_break_animation(char * dest, play_toclient_block_break_animation source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.destroy_stage);
  return dest;
}

int walk_play_toclient_tile_entity_data(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 9) {
    return -1;
  }
  size += 9;
  source += 9;
  max_len -= 9;
  if((ret = walk_optnbt(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_tile_entity_data(play_toclient_tile_entity_data packet) {
  size_t size = 0;
  size += 9;
  size += size_optnbt(packet.nbt_data);
  return size;
}

char * dec_play_toclient_tile_entity_data(play_toclient_tile_entity_data *packet, char * source) {
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->action, source);
  if(!(source = dec_optnbt(&packet->nbt_data, source))) return NULL;
  return source;
}

char * enc_play_toclient_tile_entity_data(char * dest, play_toclient_tile_entity_data source) {
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.action);
  dest = enc_optnbt(dest, source.nbt_data);
  return dest;
}

void free_play_toclient_tile_entity_data(play_toclient_tile_entity_data packet) {
  free_optnbt(packet.nbt_data);
}

int walk_play_toclient_block_action(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 10) {
    return -1;
  }
  size += 10;
  source += 10;
  max_len -= 10;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_block_action(play_toclient_block_action packet) {
  size_t size = 0;
  size += 10;
  size += size_varlong(packet.block_id);
  return size;
}

char * dec_play_toclient_block_action(play_toclient_block_action *packet, char * source) {
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->byte1, source);
  source = dec_byte(&packet->byte2, source);
  source = dec_varlong(&packet->block_id, source);
  return source;
}

char * enc_play_toclient_block_action(char * dest, play_toclient_block_action source) {
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.byte1);
  dest = enc_byte(dest, source.byte2);
  dest = enc_varlong(dest, source.block_id);
  return dest;
}

int walk_play_toclient_block_change(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_block_change(play_toclient_block_change packet) {
  size_t size = 0;
  size += 8;
  size += size_varlong(packet.type);
  return size;
}

char * dec_play_toclient_block_change(play_toclient_block_change *packet, char * source) {
  source = dec_position(&packet->location, source);
  source = dec_varlong(&packet->type, source);
  return source;
}

char * enc_play_toclient_block_change(char * dest, play_toclient_block_change source) {
  dest = enc_position(dest, source.location);
  dest = enc_varlong(dest, source.type);
  return dest;
}

int walk_play_toclient_boss_bar(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 16) {
    return -1;
  }
  size += 16;
  source += 16;
  max_len -= 16;
  int64_t action;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&action, source);
  switch(action) {
    case 3:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 2:
    case 0:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(action) {
    case 4:
    case 0:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 4:
    case 0:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 5:
    case 0:
      if(max_len < 1) {
        return -1;
      }
      size += 1;
      source += 1;
      max_len -= 1;
      break;
  }
  return size;
}

size_t size_play_toclient_boss_bar(play_toclient_boss_bar packet) {
  size_t size = 0;
  size += 16;
  size += size_varlong(packet.action);
  switch(packet.action) {
    case 3:
    case 0:
      size += size_string(packet.title);
      break;
  }
  switch(packet.action) {
    case 2:
    case 0:
      size += 4;
      break;
  }
  switch(packet.action) {
    case 4:
    case 0:
      size += size_varlong(packet.color);
      break;
  }
  switch(packet.action) {
    case 4:
    case 0:
      size += size_varlong(packet.dividers);
      break;
  }
  switch(packet.action) {
    case 5:
    case 0:
      size += 1;
      break;
  }
  return size;
}

char * dec_play_toclient_boss_bar(play_toclient_boss_bar *packet, char * source) {
  source = dec_uuid(&packet->entity_uuid, source);
  source = dec_varlong(&packet->action, source);
  switch(packet->action) {
    case 3:
    case 0:
      if(!(source = dec_string(&packet->title, source))) return NULL;
      break;
  }
  switch(packet->action) {
    case 2:
    case 0:
      source = dec_bef32(&packet->health, source);
      break;
  }
  switch(packet->action) {
    case 4:
    case 0:
      source = dec_varlong(&packet->color, source);
      break;
  }
  switch(packet->action) {
    case 4:
    case 0:
      source = dec_varlong(&packet->dividers, source);
      break;
  }
  switch(packet->action) {
    case 5:
    case 0:
      source = dec_byte(&packet->flags, source);
      break;
  }
  return source;
}

char * enc_play_toclient_boss_bar(char * dest, play_toclient_boss_bar source) {
  dest = enc_uuid(dest, source.entity_uuid);
  dest = enc_varlong(dest, source.action);
  switch(source.action) {
    case 3:
    case 0:
      dest = enc_string(dest, source.title);
      break;
  }
  switch(source.action) {
    case 2:
    case 0:
      dest = enc_bef32(dest, source.health);
      break;
  }
  switch(source.action) {
    case 4:
    case 0:
      dest = enc_varlong(dest, source.color);
      break;
  }
  switch(source.action) {
    case 4:
    case 0:
      dest = enc_varlong(dest, source.dividers);
      break;
  }
  switch(source.action) {
    case 5:
    case 0:
      dest = enc_byte(dest, source.flags);
      break;
  }
  return dest;
}

void free_play_toclient_boss_bar(play_toclient_boss_bar packet) {
  switch(packet.action) {
    case 3:
    case 0:
      free_string(packet.title);
      break;
  }
}

int walk_play_toclient_difficulty(char * source, size_t max_len) {
  if(max_len < 2) return -1;
  return 2;
}

size_t size_play_toclient_difficulty(play_toclient_difficulty packet) {
  return 2;
}

char * dec_play_toclient_difficulty(play_toclient_difficulty *packet, char * source) {
  source = dec_byte(&packet->difficulty, source);
  source = dec_byte(&packet->difficulty_locked, source);
  return source;
}

char * enc_play_toclient_difficulty(char * dest, play_toclient_difficulty source) {
  dest = enc_byte(dest, source.difficulty);
  dest = enc_byte(dest, source.difficulty_locked);
  return dest;
}

int walk_play_toclient_tab_complete(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t matches_count;
  source = dec_varlong(&matches_count, source);
  for(size_t i_0 = 0; i_0 < matches_count; ++i_0) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if(max_len < 1) {
        return -1;
    }
    uint8_t tooltip_opt;
    source = dec_byte(&tooltip_opt, source);
    size += 1;
    max_len -= 1;
    if(tooltip_opt) {
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    }
  }
  return size;
}

size_t size_play_toclient_tab_complete(play_toclient_tab_complete packet) {
  size_t size = 0;
  size += size_varlong(packet.transaction_id);
  size += size_varlong(packet.start);
  size += size_varlong(packet.length);
  size += size_varlong(packet.matches.count);
  for(size_t i_0 = 0; i_0 < packet.matches.count; ++i_0) {
    size += size_string(packet.matches.base[i_0].match);
    size += 1;
    if(packet.matches.base[i_0].tooltip.opt) {
      size += size_string(packet.matches.base[i_0].tooltip.val);
    }
  }
  return size;
}

char * dec_play_toclient_tab_complete(play_toclient_tab_complete *packet, char * source) {
  source = dec_varlong(&packet->transaction_id, source);
  source = dec_varlong(&packet->start, source);
  source = dec_varlong(&packet->length, source);
  source = dec_varlong(&packet->matches.count, source);
  if(!(packet->matches.base = malloc(sizeof(*packet->matches.base) * packet->matches.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->matches.count; ++i_0) {
    if(!(source = dec_string(&packet->matches.base[i_0].match, source))) return NULL;
    source = dec_byte(&packet->matches.base[i_0].tooltip.opt, source);
    if(packet->matches.base[i_0].tooltip.opt) {
      if(!(source = dec_string(&packet->matches.base[i_0].tooltip.val, source))) return NULL;
    }
  }
  return source;
}

char * enc_play_toclient_tab_complete(char * dest, play_toclient_tab_complete source) {
  dest = enc_varlong(dest, source.transaction_id);
  dest = enc_varlong(dest, source.start);
  dest = enc_varlong(dest, source.length);
  dest = enc_varlong(dest, source.matches.count);
  for(size_t i_0 = 0; i_0 < source.matches.count; ++i_0) {
    dest = enc_string(dest, source.matches.base[i_0].match);
    dest = enc_byte(dest, source.matches.base[i_0].tooltip.opt);
    if(source.matches.base[i_0].tooltip.opt) {
      dest = enc_string(dest, source.matches.base[i_0].tooltip.val);
    }
  }
  return dest;
}

void free_play_toclient_tab_complete(play_toclient_tab_complete packet) {
  for(size_t i_0 = 0; i_0 < packet.matches.count; ++i_0) {
    free_string(packet.matches.base[i_0].match);
    if(packet.matches.base[i_0].tooltip.opt) {
      free_string(packet.matches.base[i_0].tooltip.val);
    }
  }
  free(packet.matches.base);
}

int walk_play_toclient_declare_commands(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t nodes_count;
  source = dec_varlong(&nodes_count, source);
  for(size_t i_0 = 0; i_0 < nodes_count; ++i_0) {
    if(max_len < 1) {
      return -1;
    }
    uint8_t flags;
    size += 1;
    max_len -= 1;
    source = dec_byte(&flags, source);
    uint8_t has_custom_suggestions = (flags>>4)&1;
    uint8_t has_redirect_node = (flags>>3)&1;
    uint8_t command_node_type = (flags>>0)&3;
    if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
    }
    size += ret;
    max_len -= ret;
    int64_t children_count;
    source = dec_varlong(&children_count, source);
    for(size_t i_2 = 0; i_2 < children_count; ++i_2) {
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    }
    if(has_redirect_node) {
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    }
    switch(command_node_type) {
      case 0:
        // void condition
        break;
      case 1:
        if((ret = walk_string(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
        break;
      case 2:
        if((ret = walk_string(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
        sds parser;
        if((ret = walk_string(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        max_len -= ret;
        if(!(source = dec_string(&parser, source))) {
          return -1;
        }
        if(!(sdscmp("brigadier:double", parser))) {
          if(max_len < 1) {
            free_string(parser);
            return -1;
          }
          uint8_t flags;
          size += 1;
          max_len -= 1;
          source = dec_byte(&flags, source);
          uint8_t max_present = (flags>>1)&1;
          uint8_t min_present = (flags>>0)&1;
          if(min_present) {
            if(max_len < 8) {
              free_string(parser);
              return -1;
            }
            size += 8;
            source += 8;
            max_len -= 8;
          }
          if(max_present) {
            if(max_len < 8) {
              free_string(parser);
              return -1;
            }
            size += 8;
            source += 8;
            max_len -= 8;
          }
        } else if(!(sdscmp("brigadier:float", parser))) {
          if(max_len < 1) {
            free_string(parser);
            return -1;
          }
          uint8_t flags;
          size += 1;
          max_len -= 1;
          source = dec_byte(&flags, source);
          uint8_t max_present = (flags>>1)&1;
          uint8_t min_present = (flags>>0)&1;
          if(min_present) {
            if(max_len < 4) {
              free_string(parser);
              return -1;
            }
            size += 4;
            source += 4;
            max_len -= 4;
          }
          if(max_present) {
            if(max_len < 4) {
              free_string(parser);
              return -1;
            }
            size += 4;
            source += 4;
            max_len -= 4;
          }
        } else if(!(sdscmp("brigadier:integer", parser))) {
          if(max_len < 1) {
            free_string(parser);
            return -1;
          }
          uint8_t flags;
          size += 1;
          max_len -= 1;
          source = dec_byte(&flags, source);
          uint8_t max_present = (flags>>1)&1;
          uint8_t min_present = (flags>>0)&1;
          if(min_present) {
            if(max_len < 4) {
              free_string(parser);
              return -1;
            }
            size += 4;
            source += 4;
            max_len -= 4;
          }
          if(max_present) {
            if(max_len < 4) {
              free_string(parser);
              return -1;
            }
            size += 4;
            source += 4;
            max_len -= 4;
          }
        } else if(!(sdscmp("brigadier:string", parser))) {
          if((ret = walk_varlong(source, max_len)) < 0) {
            free_string(parser);
            return -1;
          }
          size += ret;
          source += ret;
          max_len -= ret;
        } else if(!(sdscmp("minecraft:entity", parser))) {
          if(max_len < 1) {
            free_string(parser);
            return -1;
          }
          size += 1;
          source += 1;
          max_len -= 1;
        } else if(!(sdscmp("minecraft:score_holder", parser))) {
          if(max_len < 1) {
            free_string(parser);
            return -1;
          }
          size += 1;
          source += 1;
          max_len -= 1;
        }
        if(has_custom_suggestions) {
          if((ret = walk_string(source, max_len)) < 0) {
            free_string(parser);
            return -1;
          }
          size += ret;
          source += ret;
          max_len -= ret;
        }
        free_string(parser);
        break;
    }
  }
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_declare_commands(play_toclient_declare_commands packet) {
  size_t size = 0;
  size += size_varlong(packet.nodes.count);
  for(size_t i_0 = 0; i_0 < packet.nodes.count; ++i_0) {
    size += 1;
    size += size_varlong(packet.nodes.base[i_0].children.count);
    for(size_t i_2 = 0; i_2 < packet.nodes.base[i_0].children.count; ++i_2) {
      size += size_varlong(packet.nodes.base[i_0].children.base[i_2]);
    }
    if(packet.nodes.base[i_0].flags.has_redirect_node) {
      size += size_varlong(packet.nodes.base[i_0].redirect_node);
    }
    switch(packet.nodes.base[i_0].flags.command_node_type) {
      case 0:
        // void condition
        break;
      case 1:
        size += size_string(packet.nodes.base[i_0].extra_node_data.enum_1);
        break;
      case 2:
        size += size_string(packet.nodes.base[i_0].extra_node_data.enum_2.name);
        size += size_string(packet.nodes.base[i_0].extra_node_data.enum_2.parser);
        if(!(sdscmp("brigadier:double", packet.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          size += 1;
          if(packet.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.flags.min_present) {
            size += 8;
          }
          if(packet.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.flags.max_present) {
            size += 8;
          }
        } else if(!(sdscmp("brigadier:float", packet.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          size += 1;
          if(packet.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.flags.min_present) {
            size += 4;
          }
          if(packet.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.flags.max_present) {
            size += 4;
          }
        } else if(!(sdscmp("brigadier:integer", packet.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          size += 1;
          if(packet.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.flags.min_present) {
            size += 4;
          }
          if(packet.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.flags.max_present) {
            size += 4;
          }
        } else if(!(sdscmp("brigadier:string", packet.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          size += size_varlong(packet.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_string);
        } else if(!(sdscmp("minecraft:entity", packet.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          size += 1;
        } else if(!(sdscmp("minecraft:score_holder", packet.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          size += 1;
        }
        if(packet.nodes.base[i_0].flags.has_custom_suggestions) {
          size += size_string(packet.nodes.base[i_0].extra_node_data.enum_2.suggests);
        }
        break;
    }
  }
  size += size_varlong(packet.root_index);
  return size;
}

char * dec_play_toclient_declare_commands(play_toclient_declare_commands *packet, char * source) {
  source = dec_varlong(&packet->nodes.count, source);
  if(!(packet->nodes.base = malloc(sizeof(*packet->nodes.base) * packet->nodes.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->nodes.count; ++i_0) {
    uint8_t flags;
    source = dec_byte(&flags, source);
    packet->nodes.base[i_0].flags.has_custom_suggestions = (flags>>4)&1;
    packet->nodes.base[i_0].flags.has_redirect_node = (flags>>3)&1;
    packet->nodes.base[i_0].flags.has_command = (flags>>2)&1;
    packet->nodes.base[i_0].flags.command_node_type = (flags>>0)&3;
    source = dec_varlong(&packet->nodes.base[i_0].children.count, source);
    if(!(packet->nodes.base[i_0].children.base = malloc(sizeof(*packet->nodes.base[i_0].children.base) * packet->nodes.base[i_0].children.count))) return NULL;
    for(size_t i_2 = 0; i_2 < packet->nodes.base[i_0].children.count; ++i_2) {
      source = dec_varlong(&packet->nodes.base[i_0].children.base[i_2], source);
    }
    if(packet->nodes.base[i_0].flags.has_redirect_node) {
      source = dec_varlong(&packet->nodes.base[i_0].redirect_node, source);
    }
    switch(packet->nodes.base[i_0].flags.command_node_type) {
      case 0:
        // void condition
        break;
      case 1:
        if(!(source = dec_string(&packet->nodes.base[i_0].extra_node_data.enum_1, source))) return NULL;
        break;
      case 2:
        if(!(source = dec_string(&packet->nodes.base[i_0].extra_node_data.enum_2.name, source))) return NULL;
        if(!(source = dec_string(&packet->nodes.base[i_0].extra_node_data.enum_2.parser, source))) return NULL;
        if(!(sdscmp("brigadier:double", packet->nodes.base[i_0].extra_node_data.enum_2.parser))) {
          uint8_t flags;
          source = dec_byte(&flags, source);
          packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.flags.max_present = (flags>>1)&1;
          packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.flags.min_present = (flags>>0)&1;
          if(packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.flags.min_present) {
            source = dec_bef64(&packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.min, source);
          }
          if(packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.flags.max_present) {
            source = dec_bef64(&packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.max, source);
          }
        } else if(!(sdscmp("brigadier:float", packet->nodes.base[i_0].extra_node_data.enum_2.parser))) {
          uint8_t flags;
          source = dec_byte(&flags, source);
          packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.flags.max_present = (flags>>1)&1;
          packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.flags.min_present = (flags>>0)&1;
          if(packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.flags.min_present) {
            source = dec_bef32(&packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.min, source);
          }
          if(packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.flags.max_present) {
            source = dec_bef32(&packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.max, source);
          }
        } else if(!(sdscmp("brigadier:integer", packet->nodes.base[i_0].extra_node_data.enum_2.parser))) {
          uint8_t flags;
          source = dec_byte(&flags, source);
          packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.flags.max_present = (flags>>1)&1;
          packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.flags.min_present = (flags>>0)&1;
          if(packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.flags.min_present) {
            source = dec_be32(&packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.min, source);
          }
          if(packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.flags.max_present) {
            source = dec_be32(&packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.max, source);
          }
        } else if(!(sdscmp("brigadier:string", packet->nodes.base[i_0].extra_node_data.enum_2.parser))) {
          source = dec_varlong(&packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_string, source);
        } else if(!(sdscmp("minecraft:entity", packet->nodes.base[i_0].extra_node_data.enum_2.parser))) {
          source = dec_byte(&packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_minecraft_entity, source);
        } else if(!(sdscmp("minecraft:score_holder", packet->nodes.base[i_0].extra_node_data.enum_2.parser))) {
          source = dec_byte(&packet->nodes.base[i_0].extra_node_data.enum_2.properties.enum_minecraft_score_holder, source);
        }
        if(packet->nodes.base[i_0].flags.has_custom_suggestions) {
          if(!(source = dec_string(&packet->nodes.base[i_0].extra_node_data.enum_2.suggests, source))) return NULL;
        }
        break;
    }
  }
  source = dec_varlong(&packet->root_index, source);
  return source;
}

char * enc_play_toclient_declare_commands(char * dest, play_toclient_declare_commands source) {
  dest = enc_varlong(dest, source.nodes.count);
  for(size_t i_0 = 0; i_0 < source.nodes.count; ++i_0) {
    uint8_t flags = 0;
    flags |= (source.nodes.base[i_0].flags.has_custom_suggestions&1)<<4;
    flags |= (source.nodes.base[i_0].flags.has_redirect_node&1)<<3;
    flags |= (source.nodes.base[i_0].flags.has_command&1)<<2;
    flags |= (source.nodes.base[i_0].flags.command_node_type&3)<<0;
    dest = enc_byte(dest, flags);
    dest = enc_varlong(dest, source.nodes.base[i_0].children.count);
    for(size_t i_2 = 0; i_2 < source.nodes.base[i_0].children.count; ++i_2) {
      dest = enc_varlong(dest, source.nodes.base[i_0].children.base[i_2]);
    }
    if(source.nodes.base[i_0].flags.has_redirect_node) {
      dest = enc_varlong(dest, source.nodes.base[i_0].redirect_node);
    }
    switch(source.nodes.base[i_0].flags.command_node_type) {
      case 0:
        // void condition
        break;
      case 1:
        dest = enc_string(dest, source.nodes.base[i_0].extra_node_data.enum_1);
        break;
      case 2:
        dest = enc_string(dest, source.nodes.base[i_0].extra_node_data.enum_2.name);
        dest = enc_string(dest, source.nodes.base[i_0].extra_node_data.enum_2.parser);
        if(!(sdscmp("brigadier:double", source.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          uint8_t flags = 0;
          flags |= (source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.flags.max_present&1)<<1;
          flags |= (source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.flags.min_present&1)<<0;
          dest = enc_byte(dest, flags);
          if(source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.flags.min_present) {
            dest = enc_bef64(dest, source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.min);
          }
          if(source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.flags.max_present) {
            dest = enc_bef64(dest, source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_double.max);
          }
        } else if(!(sdscmp("brigadier:float", source.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          uint8_t flags = 0;
          flags |= (source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.flags.max_present&1)<<1;
          flags |= (source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.flags.min_present&1)<<0;
          dest = enc_byte(dest, flags);
          if(source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.flags.min_present) {
            dest = enc_bef32(dest, source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.min);
          }
          if(source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.flags.max_present) {
            dest = enc_bef32(dest, source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_float.max);
          }
        } else if(!(sdscmp("brigadier:integer", source.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          uint8_t flags = 0;
          flags |= (source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.flags.max_present&1)<<1;
          flags |= (source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.flags.min_present&1)<<0;
          dest = enc_byte(dest, flags);
          if(source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.flags.min_present) {
            dest = enc_be32(dest, source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.min);
          }
          if(source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.flags.max_present) {
            dest = enc_be32(dest, source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_integer.max);
          }
        } else if(!(sdscmp("brigadier:string", source.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          dest = enc_varlong(dest, source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_brigadier_string);
        } else if(!(sdscmp("minecraft:entity", source.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          dest = enc_byte(dest, source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_minecraft_entity);
        } else if(!(sdscmp("minecraft:score_holder", source.nodes.base[i_0].extra_node_data.enum_2.parser))) {
          dest = enc_byte(dest, source.nodes.base[i_0].extra_node_data.enum_2.properties.enum_minecraft_score_holder);
        }
        if(source.nodes.base[i_0].flags.has_custom_suggestions) {
          dest = enc_string(dest, source.nodes.base[i_0].extra_node_data.enum_2.suggests);
        }
        break;
    }
  }
  dest = enc_varlong(dest, source.root_index);
  return dest;
}

void free_play_toclient_declare_commands(play_toclient_declare_commands packet) {
  for(size_t i_0 = 0; i_0 < packet.nodes.count; ++i_0) {
    free(packet.nodes.base[i_0].children.base);
    switch(packet.nodes.base[i_0].flags.command_node_type) {
      case 0:
        // No free-able types
        break;
      case 1:
        free_string(packet.nodes.base[i_0].extra_node_data.enum_1);
        break;
      case 2:
        free_string(packet.nodes.base[i_0].extra_node_data.enum_2.name);
        free_string(packet.nodes.base[i_0].extra_node_data.enum_2.parser);
        if(packet.nodes.base[i_0].flags.has_custom_suggestions) {
          free_string(packet.nodes.base[i_0].extra_node_data.enum_2.suggests);
        }
        break;
    }
  }
  free(packet.nodes.base);
}

int walk_play_toclient_face_player(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 24) {
    return -1;
  }
  size += 24;
  source += 24;
  max_len -= 24;
  uint8_t is_entity;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  max_len -= 1;
  source = dec_byte(&is_entity, source);
  if(is_entity) {
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  if(is_entity) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_face_player(play_toclient_face_player packet) {
  size_t size = 0;
  size += size_string(packet.feet_eyes);
  size += 25;
  if(packet.is_entity) {
    size += size_varlong(packet.entity_id);
  }
  if(packet.is_entity) {
    size += size_string(packet.entity_feet_eyes);
  }
  return size;
}

char * dec_play_toclient_face_player(play_toclient_face_player *packet, char * source) {
  if(!(source = dec_string(&packet->feet_eyes, source))) return NULL;
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_byte(&packet->is_entity, source);
  if(packet->is_entity) {
    source = dec_varlong(&packet->entity_id, source);
  }
  if(packet->is_entity) {
    if(!(source = dec_string(&packet->entity_feet_eyes, source))) return NULL;
  }
  return source;
}

char * enc_play_toclient_face_player(char * dest, play_toclient_face_player source) {
  dest = enc_string(dest, source.feet_eyes);
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_byte(dest, source.is_entity);
  if(source.is_entity) {
    dest = enc_varlong(dest, source.entity_id);
  }
  if(source.is_entity) {
    dest = enc_string(dest, source.entity_feet_eyes);
  }
  return dest;
}

void free_play_toclient_face_player(play_toclient_face_player packet) {
  free_string(packet.feet_eyes);
  if(packet.is_entity) {
    free_string(packet.entity_feet_eyes);
  }
}

int walk_play_toclient_nbt_query_response(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_nbt(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_nbt_query_response(play_toclient_nbt_query_response packet) {
  size_t size = 0;
  size += size_varlong(packet.transaction_id);
  size += size_nbt(packet.nbt);
  return size;
}

char * dec_play_toclient_nbt_query_response(play_toclient_nbt_query_response *packet, char * source) {
  source = dec_varlong(&packet->transaction_id, source);
  if(!(source = dec_nbt(&packet->nbt, source))) return NULL;
  return source;
}

char * enc_play_toclient_nbt_query_response(char * dest, play_toclient_nbt_query_response source) {
  dest = enc_varlong(dest, source.transaction_id);
  dest = enc_nbt(dest, source.nbt);
  return dest;
}

void free_play_toclient_nbt_query_response(play_toclient_nbt_query_response packet) {
  free_nbt(packet.nbt);
}

int walk_play_toclient_chat(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_chat(play_toclient_chat packet) {
  size_t size = 0;
  size += size_string(packet.message);
  return size + 1;
}

char * dec_play_toclient_chat(play_toclient_chat *packet, char * source) {
  if(!(source = dec_string(&packet->message, source))) return NULL;
  source = dec_byte(&packet->position, source);
  return source;
}

char * enc_play_toclient_chat(char * dest, play_toclient_chat source) {
  dest = enc_string(dest, source.message);
  dest = enc_byte(dest, source.position);
  return dest;
}

void free_play_toclient_chat(play_toclient_chat packet) {
  free_string(packet.message);
}

int walk_play_toclient_multi_block_change(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
      return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t records_count;
  source = dec_varlong(&records_count, source);
  for(size_t i_0 = 0; i_0 < records_count; ++i_0) {
    if(max_len < 2) {
      return -1;
    }
    size += 2;
    source += 2;
    max_len -= 2;
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_multi_block_change(play_toclient_multi_block_change packet) {
  size_t size = 0;
  size += 8;
  size += size_varlong(packet.records.count);
  for(size_t i_0 = 0; i_0 < packet.records.count; ++i_0) {
    size += 2;
    size += size_varlong(packet.records.base[i_0].block_id);
  }
  return size;
}

char * dec_play_toclient_multi_block_change(play_toclient_multi_block_change *packet, char * source) {
  source = dec_be32(&packet->chunk_x, source);
  source = dec_be32(&packet->chunk_z, source);
  source = dec_varlong(&packet->records.count, source);
  if(!(packet->records.base = malloc(sizeof(*packet->records.base) * packet->records.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->records.count; ++i_0) {
    source = dec_byte(&packet->records.base[i_0].horizontal_pos, source);
    source = dec_byte(&packet->records.base[i_0].y, source);
    source = dec_varlong(&packet->records.base[i_0].block_id, source);
  }
  return source;
}

char * enc_play_toclient_multi_block_change(char * dest, play_toclient_multi_block_change source) {
  dest = enc_be32(dest, source.chunk_x);
  dest = enc_be32(dest, source.chunk_z);
  dest = enc_varlong(dest, source.records.count);
  for(size_t i_0 = 0; i_0 < source.records.count; ++i_0) {
    dest = enc_byte(dest, source.records.base[i_0].horizontal_pos);
    dest = enc_byte(dest, source.records.base[i_0].y);
    dest = enc_varlong(dest, source.records.base[i_0].block_id);
  }
  return dest;
}

void free_play_toclient_multi_block_change(play_toclient_multi_block_change packet) {
  free(packet.records.base);
}

int walk_play_toclient_transaction(char * source, size_t max_len) {
  if(max_len < 4) return -1;
  return 4;
}

size_t size_play_toclient_transaction(play_toclient_transaction packet) {
  return 4;
}

char * dec_play_toclient_transaction(play_toclient_transaction *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->action, source);
  source = dec_byte(&packet->accepted, source);
  return source;
}

char * enc_play_toclient_transaction(char * dest, play_toclient_transaction source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.action);
  dest = enc_byte(dest, source.accepted);
  return dest;
}

int walk_play_toclient_close_window(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toclient_close_window(play_toclient_close_window packet) {
  return 1;
}

char * dec_play_toclient_close_window(play_toclient_close_window *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  return source;
}

char * enc_play_toclient_close_window(char * dest, play_toclient_close_window source) {
  dest = enc_byte(dest, source.window_id);
  return dest;
}

int walk_play_toclient_open_window(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_open_window(play_toclient_open_window packet) {
  size_t size = 0;
  size += size_varlong(packet.window_id);
  size += size_varlong(packet.inventory_type);
  size += size_string(packet.window_title);
  return size;
}

char * dec_play_toclient_open_window(play_toclient_open_window *packet, char * source) {
  source = dec_varlong(&packet->window_id, source);
  source = dec_varlong(&packet->inventory_type, source);
  if(!(source = dec_string(&packet->window_title, source))) return NULL;
  return source;
}

char * enc_play_toclient_open_window(char * dest, play_toclient_open_window source) {
  dest = enc_varlong(dest, source.window_id);
  dest = enc_varlong(dest, source.inventory_type);
  dest = enc_string(dest, source.window_title);
  return dest;
}

void free_play_toclient_open_window(play_toclient_open_window packet) {
  free_string(packet.window_title);
}

int walk_play_toclient_window_items(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
      return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if(max_len < 2) {
      return -1;
  }
  size += 2;
  max_len -= 2;
  int16_t items_count;
  source = dec_be16(&items_count, source);
  for(size_t i_0 = 0; i_0 < items_count; ++i_0) {
    if((ret = walk_slot(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_window_items(play_toclient_window_items packet) {
  size_t size = 0;
  size += 1;
  size += 2;
  for(size_t i_0 = 0; i_0 < packet.items.count; ++i_0) {
    size += size_slot(packet.items.base[i_0]);
  }
  return size;
}

char * dec_play_toclient_window_items(play_toclient_window_items *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->items.count, source);
  if(!(packet->items.base = malloc(sizeof(*packet->items.base) * packet->items.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->items.count; ++i_0) {
    if(!(source = dec_slot(&packet->items.base[i_0], source))) return NULL;
  }
  return source;
}

char * enc_play_toclient_window_items(char * dest, play_toclient_window_items source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.items.count);
  for(size_t i_0 = 0; i_0 < source.items.count; ++i_0) {
    dest = enc_slot(dest, source.items.base[i_0]);
  }
  return dest;
}

void free_play_toclient_window_items(play_toclient_window_items packet) {
  for(size_t i_0 = 0; i_0 < packet.items.count; ++i_0) {
    free_slot(packet.items.base[i_0]);
  }
  free(packet.items.base);
}

int walk_play_toclient_craft_progress_bar(char * source, size_t max_len) {
  if(max_len < 5) return -1;
  return 5;
}

size_t size_play_toclient_craft_progress_bar(play_toclient_craft_progress_bar packet) {
  return 5;
}

char * dec_play_toclient_craft_progress_bar(play_toclient_craft_progress_bar *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->property, source);
  source = dec_be16(&packet->value, source);
  return source;
}

char * enc_play_toclient_craft_progress_bar(char * dest, play_toclient_craft_progress_bar source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.property);
  dest = enc_be16(dest, source.value);
  return dest;
}

int walk_play_toclient_set_slot(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 3) {
    return -1;
  }
  size += 3;
  source += 3;
  max_len -= 3;
  if((ret = walk_slot(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_set_slot(play_toclient_set_slot packet) {
  size_t size = 0;
  size += 3;
  size += size_slot(packet.item);
  return size;
}

char * dec_play_toclient_set_slot(play_toclient_set_slot *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->slot, source);
  if(!(source = dec_slot(&packet->item, source))) return NULL;
  return source;
}

char * enc_play_toclient_set_slot(char * dest, play_toclient_set_slot source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.slot);
  dest = enc_slot(dest, source.item);
  return dest;
}

void free_play_toclient_set_slot(play_toclient_set_slot packet) {
  free_slot(packet.item);
}

int walk_play_toclient_set_cooldown(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_set_cooldown(play_toclient_set_cooldown packet) {
  size_t size = 0;
  size += size_varlong(packet.item_id);
  size += size_varlong(packet.cooldown_ticks);
  return size;
}

char * dec_play_toclient_set_cooldown(play_toclient_set_cooldown *packet, char * source) {
  source = dec_varlong(&packet->item_id, source);
  source = dec_varlong(&packet->cooldown_ticks, source);
  return source;
}

char * enc_play_toclient_set_cooldown(char * dest, play_toclient_set_cooldown source) {
  dest = enc_varlong(dest, source.item_id);
  dest = enc_varlong(dest, source.cooldown_ticks);
  return dest;
}

int walk_play_toclient_custom_payload(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  ret = max_len;
  return size + ret;
}

size_t size_play_toclient_custom_payload(play_toclient_custom_payload packet) {
  size_t size = 0;
  size += size_string(packet.channel);
  size += packet.data.len;
  return size;
}

char * dec_play_toclient_custom_payload(play_toclient_custom_payload *packet, char * source, size_t total_size) {
  char * endptr = source + total_size;
  if(!(source = dec_string(&packet->channel, source))) return NULL;
  source = dec_buffer(&packet->data, source, endptr - source);
  return source;
}

char * enc_play_toclient_custom_payload(char * dest, play_toclient_custom_payload source) {
  dest = enc_string(dest, source.channel);
  dest = enc_buffer(dest, source.data);
  return dest;
}

void free_play_toclient_custom_payload(play_toclient_custom_payload packet) {
  free_string(packet.channel);
  free(packet.data.base);
}

int walk_play_toclient_named_sound_effect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 20) {
    return -1;
  }
  return size + 20;
}

size_t size_play_toclient_named_sound_effect(play_toclient_named_sound_effect packet) {
  size_t size = 0;
  size += size_string(packet.sound_name);
  size += size_varlong(packet.sound_category);
  return size + 20;
}

char * dec_play_toclient_named_sound_effect(play_toclient_named_sound_effect *packet, char * source) {
  if(!(source = dec_string(&packet->sound_name, source))) return NULL;
  source = dec_varlong(&packet->sound_category, source);
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->y, source);
  source = dec_be32(&packet->z, source);
  source = dec_bef32(&packet->volume, source);
  source = dec_bef32(&packet->pitch, source);
  return source;
}

char * enc_play_toclient_named_sound_effect(char * dest, play_toclient_named_sound_effect source) {
  dest = enc_string(dest, source.sound_name);
  dest = enc_varlong(dest, source.sound_category);
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.y);
  dest = enc_be32(dest, source.z);
  dest = enc_bef32(dest, source.volume);
  dest = enc_bef32(dest, source.pitch);
  return dest;
}

void free_play_toclient_named_sound_effect(play_toclient_named_sound_effect packet) {
  free_string(packet.sound_name);
}

int walk_play_toclient_kick_disconnect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_kick_disconnect(play_toclient_kick_disconnect packet) {
  size_t size = 0;
  size += size_string(packet.reason);
  return size;
}

char * dec_play_toclient_kick_disconnect(play_toclient_kick_disconnect *packet, char * source) {
  if(!(source = dec_string(&packet->reason, source))) return NULL;
  return source;
}

char * enc_play_toclient_kick_disconnect(char * dest, play_toclient_kick_disconnect source) {
  dest = enc_string(dest, source.reason);
  return dest;
}

void free_play_toclient_kick_disconnect(play_toclient_kick_disconnect packet) {
  free_string(packet.reason);
}

int walk_play_toclient_entity_status(char * source, size_t max_len) {
  if(max_len < 5) return -1;
  return 5;
}

size_t size_play_toclient_entity_status(play_toclient_entity_status packet) {
  return 5;
}

char * dec_play_toclient_entity_status(play_toclient_entity_status *packet, char * source) {
  source = dec_be32(&packet->entity_id, source);
  source = dec_byte(&packet->entity_status, source);
  return source;
}

char * enc_play_toclient_entity_status(char * dest, play_toclient_entity_status source) {
  dest = enc_be32(dest, source.entity_id);
  dest = enc_byte(dest, source.entity_status);
  return dest;
}

int walk_play_toclient_explosion(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 16) {
    return -1;
  }
  size += 16;
  source += 16;
  max_len -= 16;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  max_len -= 4;
  int32_t affected_block_offsets_count;
  source = dec_be32(&affected_block_offsets_count, source);
  if(max_len < affected_block_offsets_count * 3) {
    return -1;
  }
  size += affected_block_offsets_count * 3;
  source += affected_block_offsets_count * 3;
  max_len -= affected_block_offsets_count * 3;
  if(max_len < 12) {
    return -1;
  }
  return size + 12;
}

size_t size_play_toclient_explosion(play_toclient_explosion packet) {
  size_t size = 0;
  size += 16;
  size += 4;
  size += packet.affected_block_offsets.count * 3;
  return size + 12;
}

char * dec_play_toclient_explosion(play_toclient_explosion *packet, char * source) {
  source = dec_bef32(&packet->x, source);
  source = dec_bef32(&packet->y, source);
  source = dec_bef32(&packet->z, source);
  source = dec_bef32(&packet->radius, source);
  source = dec_be32(&packet->affected_block_offsets.count, source);
  if(!(packet->affected_block_offsets.base = malloc(sizeof(*packet->affected_block_offsets.base) * packet->affected_block_offsets.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->affected_block_offsets.count; ++i_0) {
    source = dec_byte(&packet->affected_block_offsets.base[i_0].x, source);
    source = dec_byte(&packet->affected_block_offsets.base[i_0].y, source);
    source = dec_byte(&packet->affected_block_offsets.base[i_0].z, source);
  }
  source = dec_bef32(&packet->player_motion_x, source);
  source = dec_bef32(&packet->player_motion_y, source);
  source = dec_bef32(&packet->player_motion_z, source);
  return source;
}

char * enc_play_toclient_explosion(char * dest, play_toclient_explosion source) {
  dest = enc_bef32(dest, source.x);
  dest = enc_bef32(dest, source.y);
  dest = enc_bef32(dest, source.z);
  dest = enc_bef32(dest, source.radius);
  dest = enc_be32(dest, source.affected_block_offsets.count);
  for(size_t i_0 = 0; i_0 < source.affected_block_offsets.count; ++i_0) {
    dest = enc_byte(dest, source.affected_block_offsets.base[i_0].x);
    dest = enc_byte(dest, source.affected_block_offsets.base[i_0].y);
    dest = enc_byte(dest, source.affected_block_offsets.base[i_0].z);
  }
  dest = enc_bef32(dest, source.player_motion_x);
  dest = enc_bef32(dest, source.player_motion_y);
  dest = enc_bef32(dest, source.player_motion_z);
  return dest;
}

void free_play_toclient_explosion(play_toclient_explosion packet) {
  free(packet.affected_block_offsets.base);
}

int walk_play_toclient_unload_chunk(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_play_toclient_unload_chunk(play_toclient_unload_chunk packet) {
  return 8;
}

char * dec_play_toclient_unload_chunk(play_toclient_unload_chunk *packet, char * source) {
  source = dec_be32(&packet->chunk_x, source);
  source = dec_be32(&packet->chunk_z, source);
  return source;
}

char * enc_play_toclient_unload_chunk(char * dest, play_toclient_unload_chunk source) {
  dest = enc_be32(dest, source.chunk_x);
  dest = enc_be32(dest, source.chunk_z);
  return dest;
}

int walk_play_toclient_game_state_change(char * source, size_t max_len) {
  if(max_len < 5) return -1;
  return 5;
}

size_t size_play_toclient_game_state_change(play_toclient_game_state_change packet) {
  return 5;
}

char * dec_play_toclient_game_state_change(play_toclient_game_state_change *packet, char * source) {
  source = dec_byte(&packet->reason, source);
  source = dec_bef32(&packet->game_mode, source);
  return source;
}

char * enc_play_toclient_game_state_change(char * dest, play_toclient_game_state_change source) {
  dest = enc_byte(dest, source.reason);
  dest = enc_bef32(dest, source.game_mode);
  return dest;
}

int walk_play_toclient_open_horse_window(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 4) {
    return -1;
  }
  return size + 4;
}

size_t size_play_toclient_open_horse_window(play_toclient_open_horse_window packet) {
  size_t size = 0;
  size += 1;
  size += size_varlong(packet.nb_slots);
  return size + 4;
}

char * dec_play_toclient_open_horse_window(play_toclient_open_horse_window *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_varlong(&packet->nb_slots, source);
  source = dec_be32(&packet->entity_id, source);
  return source;
}

char * enc_play_toclient_open_horse_window(char * dest, play_toclient_open_horse_window source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_varlong(dest, source.nb_slots);
  dest = enc_be32(dest, source.entity_id);
  return dest;
}

int walk_play_toclient_keep_alive(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_play_toclient_keep_alive(play_toclient_keep_alive packet) {
  return 8;
}

char * dec_play_toclient_keep_alive(play_toclient_keep_alive *packet, char * source) {
  source = dec_be64(&packet->keep_alive_id, source);
  return source;
}

char * enc_play_toclient_keep_alive(char * dest, play_toclient_keep_alive source) {
  dest = enc_be64(dest, source.keep_alive_id);
  return dest;
}

int walk_play_toclient_map_chunk(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 9) {
    return -1;
  }
  size += 9;
  source += 9;
  max_len -= 9;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_nbt(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t chunk_data_len;
  source = dec_varlong(&chunk_data_len, source);
  if(max_len < chunk_data_len) {
    return -1;
  }
  size += chunk_data_len;
  source += chunk_data_len;
  max_len -= chunk_data_len;
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t block_entities_count;
  source = dec_varlong(&block_entities_count, source);
  for(size_t i_0 = 0; i_0 < block_entities_count; ++i_0) {
    if((ret = walk_nbt(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_map_chunk(play_toclient_map_chunk packet) {
  size_t size = 0;
  size += 9;
  size += size_varlong(packet.bit_map);
  size += size_nbt(packet.heightmaps);
  size += size_varlong(packet.chunk_data.len);
  size += packet.chunk_data.len;
  size += size_varlong(packet.block_entities.count);
  for(size_t i_0 = 0; i_0 < packet.block_entities.count; ++i_0) {
    size += size_nbt(packet.block_entities.base[i_0]);
  }
  return size;
}

char * dec_play_toclient_map_chunk(play_toclient_map_chunk *packet, char * source) {
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->z, source);
  source = dec_byte(&packet->ground_up, source);
  source = dec_varlong(&packet->bit_map, source);
  if(!(source = dec_nbt(&packet->heightmaps, source))) return NULL;
  source = dec_varlong(&packet->chunk_data.len, source);
  if(!(packet->chunk_data.base = malloc(packet->chunk_data.len))) return NULL;
  memcpy(packet->chunk_data.base, source, packet->chunk_data.len);
  source += packet->chunk_data.len;
  source = dec_varlong(&packet->block_entities.count, source);
  if(!(packet->block_entities.base = malloc(sizeof(*packet->block_entities.base) * packet->block_entities.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->block_entities.count; ++i_0) {
    if(!(source = dec_nbt(&packet->block_entities.base[i_0], source))) return NULL;
  }
  return source;
}

char * enc_play_toclient_map_chunk(char * dest, play_toclient_map_chunk source) {
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.z);
  dest = enc_byte(dest, source.ground_up);
  dest = enc_varlong(dest, source.bit_map);
  dest = enc_nbt(dest, source.heightmaps);
  dest = enc_varlong(dest, source.chunk_data.len);
  dest = memcpy(dest, source.chunk_data.base, source.chunk_data.len);
  dest = enc_varlong(dest, source.block_entities.count);
  for(size_t i_0 = 0; i_0 < source.block_entities.count; ++i_0) {
    dest = enc_nbt(dest, source.block_entities.base[i_0]);
  }
  return dest;
}

void free_play_toclient_map_chunk(play_toclient_map_chunk packet) {
  free_nbt(packet.heightmaps);
  free(packet.chunk_data.base);
  for(size_t i_0 = 0; i_0 < packet.block_entities.count; ++i_0) {
    free_nbt(packet.block_entities.base[i_0]);
  }
  free(packet.block_entities.base);
}

int walk_play_toclient_world_event(char * source, size_t max_len) {
  if(max_len < 17) return -1;
  return 17;
}

size_t size_play_toclient_world_event(play_toclient_world_event packet) {
  return 17;
}

char * dec_play_toclient_world_event(play_toclient_world_event *packet, char * source) {
  source = dec_be32(&packet->effect_id, source);
  source = dec_position(&packet->location, source);
  source = dec_be32(&packet->data, source);
  source = dec_byte(&packet->global, source);
  return source;
}

char * enc_play_toclient_world_event(char * dest, play_toclient_world_event source) {
  dest = enc_be32(dest, source.effect_id);
  dest = enc_position(dest, source.location);
  dest = enc_be32(dest, source.data);
  dest = enc_byte(dest, source.global);
  return dest;
}

int walk_play_toclient_world_particles(char * source, size_t max_len) {
  int ret, size = 0;
  int32_t particle_id;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  max_len -= 4;
  source = dec_be32(&particle_id, source);
  if(max_len < 33) {
    return -1;
  }
  size += 33;
  source += 33;
  max_len -= 33;
  if((ret = walk_particledata(source, max_len, particle_id)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_world_particles(play_toclient_world_particles packet) {
  size_t size = 0;
  size += 37;
  size += size_particledata(packet.data);
  return size;
}

char * dec_play_toclient_world_particles(play_toclient_world_particles *packet, char * source) {
  source = dec_be32(&packet->particle_id, source);
  source = dec_byte(&packet->long_distance, source);
  source = dec_bef32(&packet->x, source);
  source = dec_bef32(&packet->y, source);
  source = dec_bef32(&packet->z, source);
  source = dec_bef32(&packet->offset_x, source);
  source = dec_bef32(&packet->offset_y, source);
  source = dec_bef32(&packet->offset_z, source);
  source = dec_bef32(&packet->particle_data, source);
  source = dec_be32(&packet->particles, source);
  source = dec_particledata(&packet->data, source, packet->particle_id);
  return source;
}

char * enc_play_toclient_world_particles(char * dest, play_toclient_world_particles source) {
  dest = enc_be32(dest, source.particle_id);
  dest = enc_byte(dest, source.long_distance);
  dest = enc_bef32(dest, source.x);
  dest = enc_bef32(dest, source.y);
  dest = enc_bef32(dest, source.z);
  dest = enc_bef32(dest, source.offset_x);
  dest = enc_bef32(dest, source.offset_y);
  dest = enc_bef32(dest, source.offset_z);
  dest = enc_bef32(dest, source.particle_data);
  dest = enc_be32(dest, source.particles);
  dest = enc_particledata(dest, source.data);
  return dest;
}

void free_play_toclient_world_particles(play_toclient_world_particles packet) {
  free_particledata(packet.data);
}

int walk_play_toclient_update_light(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  ret = max_len;
  return size + ret;
}

size_t size_play_toclient_update_light(play_toclient_update_light packet) {
  size_t size = 0;
  size += size_varlong(packet.chunk_x);
  size += size_varlong(packet.chunk_z);
  size += size_varlong(packet.sky_light_mask);
  size += size_varlong(packet.block_light_mask);
  size += size_varlong(packet.empty_sky_light_mask);
  size += size_varlong(packet.empty_block_light_mask);
  size += packet.data.len;
  return size;
}

char * dec_play_toclient_update_light(play_toclient_update_light *packet, char * source, size_t total_size) {
  char * endptr = source + total_size;
  source = dec_varlong(&packet->chunk_x, source);
  source = dec_varlong(&packet->chunk_z, source);
  source = dec_varlong(&packet->sky_light_mask, source);
  source = dec_varlong(&packet->block_light_mask, source);
  source = dec_varlong(&packet->empty_sky_light_mask, source);
  source = dec_varlong(&packet->empty_block_light_mask, source);
  source = dec_buffer(&packet->data, source, endptr - source);
  return source;
}

char * enc_play_toclient_update_light(char * dest, play_toclient_update_light source) {
  dest = enc_varlong(dest, source.chunk_x);
  dest = enc_varlong(dest, source.chunk_z);
  dest = enc_varlong(dest, source.sky_light_mask);
  dest = enc_varlong(dest, source.block_light_mask);
  dest = enc_varlong(dest, source.empty_sky_light_mask);
  dest = enc_varlong(dest, source.empty_block_light_mask);
  dest = enc_buffer(dest, source.data);
  return dest;
}

void free_play_toclient_update_light(play_toclient_update_light packet) {
  free(packet.data.base);
}

int walk_play_toclient_login(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 10) {
    return -1;
  }
  size += 10;
  source += 10;
  max_len -= 10;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_login(play_toclient_login packet) {
  size_t size = 0;
  size += 10;
  size += size_string(packet.level_type);
  size += size_varlong(packet.view_distance);
  return size + 1;
}

char * dec_play_toclient_login(play_toclient_login *packet, char * source) {
  source = dec_be32(&packet->entity_id, source);
  source = dec_byte(&packet->game_mode, source);
  source = dec_be32(&packet->dimension, source);
  source = dec_byte(&packet->max_players, source);
  if(!(source = dec_string(&packet->level_type, source))) return NULL;
  source = dec_varlong(&packet->view_distance, source);
  source = dec_byte(&packet->reduced_debug_info, source);
  return source;
}

char * enc_play_toclient_login(char * dest, play_toclient_login source) {
  dest = enc_be32(dest, source.entity_id);
  dest = enc_byte(dest, source.game_mode);
  dest = enc_be32(dest, source.dimension);
  dest = enc_byte(dest, source.max_players);
  dest = enc_string(dest, source.level_type);
  dest = enc_varlong(dest, source.view_distance);
  dest = enc_byte(dest, source.reduced_debug_info);
  return dest;
}

void free_play_toclient_login(play_toclient_login packet) {
  free_string(packet.level_type);
}

int walk_play_toclient_map(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 3) {
    return -1;
  }
  size += 3;
  source += 3;
  max_len -= 3;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t icons_count;
  source = dec_varlong(&icons_count, source);
  for(size_t i_0 = 0; i_0 < icons_count; ++i_0) {
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if(max_len < 3) {
      return -1;
    }
    size += 3;
    source += 3;
    max_len -= 3;
    if(max_len < 1) {
        return -1;
    }
    uint8_t display_name_opt;
    source = dec_byte(&display_name_opt, source);
    size += 1;
    max_len -= 1;
    if(display_name_opt) {
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    }
  }
  int8_t columns;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  max_len -= 1;
  source = dec_byte(&columns, source);
  switch(columns) {
    case 0:
      // void condition
      break;
    default:
      if(max_len < 1) {
        return -1;
      }
      size += 1;
      source += 1;
      max_len -= 1;
  }
  switch(columns) {
    case 0:
      // void condition
      break;
    default:
      if(max_len < 1) {
        return -1;
      }
      size += 1;
      source += 1;
      max_len -= 1;
  }
  switch(columns) {
    case 0:
      // void condition
      break;
    default:
      if(max_len < 1) {
        return -1;
      }
      size += 1;
      source += 1;
      max_len -= 1;
  }
  switch(columns) {
    case 0:
      // void condition
      break;
    default:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      max_len -= ret;
      int64_t data_len;
      source = dec_varlong(&data_len, source);
      if(max_len < data_len) {
        return -1;
      }
      size += data_len;
      source += data_len;
      max_len -= data_len;
  }
  return size;
}

size_t size_play_toclient_map(play_toclient_map packet) {
  size_t size = 0;
  size += size_varlong(packet.item_damage);
  size += 3;
  size += size_varlong(packet.icons.count);
  for(size_t i_0 = 0; i_0 < packet.icons.count; ++i_0) {
    size += size_varlong(packet.icons.base[i_0].type);
    size += 3;
    size += 1;
    if(packet.icons.base[i_0].display_name.opt) {
      size += size_string(packet.icons.base[i_0].display_name.val);
    }
  }
  size += 1;
  switch(packet.columns) {
    case 0:
      // void condition
      break;
    default:
      size += 1;
  }
  switch(packet.columns) {
    case 0:
      // void condition
      break;
    default:
      size += 1;
  }
  switch(packet.columns) {
    case 0:
      // void condition
      break;
    default:
      size += 1;
  }
  switch(packet.columns) {
    case 0:
      // void condition
      break;
    default:
      size += size_varlong(packet.data.len);
      size += packet.data.len;
  }
  return size;
}

char * dec_play_toclient_map(play_toclient_map *packet, char * source) {
  source = dec_varlong(&packet->item_damage, source);
  source = dec_byte(&packet->scale, source);
  source = dec_byte(&packet->tracking_position, source);
  source = dec_byte(&packet->locked, source);
  source = dec_varlong(&packet->icons.count, source);
  if(!(packet->icons.base = malloc(sizeof(*packet->icons.base) * packet->icons.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->icons.count; ++i_0) {
    source = dec_varlong(&packet->icons.base[i_0].type, source);
    source = dec_byte(&packet->icons.base[i_0].x, source);
    source = dec_byte(&packet->icons.base[i_0].y, source);
    source = dec_byte(&packet->icons.base[i_0].direction, source);
    source = dec_byte(&packet->icons.base[i_0].display_name.opt, source);
    if(packet->icons.base[i_0].display_name.opt) {
      if(!(source = dec_string(&packet->icons.base[i_0].display_name.val, source))) return NULL;
    }
  }
  source = dec_byte(&packet->columns, source);
  switch(packet->columns) {
    case 0:
      // void condition
      break;
    default:
      source = dec_byte(&packet->rows, source);
  }
  switch(packet->columns) {
    case 0:
      // void condition
      break;
    default:
      source = dec_byte(&packet->x, source);
  }
  switch(packet->columns) {
    case 0:
      // void condition
      break;
    default:
      source = dec_byte(&packet->y, source);
  }
  switch(packet->columns) {
    case 0:
      // void condition
      break;
    default:
      source = dec_varlong(&packet->data.len, source);
      if(!(packet->data.base = malloc(packet->data.len))) return NULL;
      memcpy(packet->data.base, source, packet->data.len);
      source += packet->data.len;
  }
  return source;
}

char * enc_play_toclient_map(char * dest, play_toclient_map source) {
  dest = enc_varlong(dest, source.item_damage);
  dest = enc_byte(dest, source.scale);
  dest = enc_byte(dest, source.tracking_position);
  dest = enc_byte(dest, source.locked);
  dest = enc_varlong(dest, source.icons.count);
  for(size_t i_0 = 0; i_0 < source.icons.count; ++i_0) {
    dest = enc_varlong(dest, source.icons.base[i_0].type);
    dest = enc_byte(dest, source.icons.base[i_0].x);
    dest = enc_byte(dest, source.icons.base[i_0].y);
    dest = enc_byte(dest, source.icons.base[i_0].direction);
    dest = enc_byte(dest, source.icons.base[i_0].display_name.opt);
    if(source.icons.base[i_0].display_name.opt) {
      dest = enc_string(dest, source.icons.base[i_0].display_name.val);
    }
  }
  dest = enc_byte(dest, source.columns);
  switch(source.columns) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_byte(dest, source.rows);
  }
  switch(source.columns) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_byte(dest, source.x);
  }
  switch(source.columns) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_byte(dest, source.y);
  }
  switch(source.columns) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_varlong(dest, source.data.len);
      dest = memcpy(dest, source.data.base, source.data.len);
  }
  return dest;
}

void free_play_toclient_map(play_toclient_map packet) {
  for(size_t i_0 = 0; i_0 < packet.icons.count; ++i_0) {
    if(packet.icons.base[i_0].display_name.opt) {
      free_string(packet.icons.base[i_0].display_name.val);
    }
  }
  free(packet.icons.base);
  switch(packet.columns) {
    case 0:
      // No free-able types
      break;
    default:
      free(packet.data.base);
  }
}

int walk_play_toclient_trade_list(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  max_len -= 1;
  uint8_t trades_count;
  source = dec_byte(&trades_count, source);
  for(size_t i_0 = 0; i_0 < trades_count; ++i_0) {
    if((ret = walk_slot(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if((ret = walk_slot(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if(max_len < 1) {
      return -1;
    }
    uint8_t input_item2_opt;
    source = dec_byte(&input_item2_opt, source);
    size += 1;
    max_len -= 1;
    if(input_item2_opt) {
      if((ret = walk_slot(source, max_len)) < 0) {
      return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    }
    if(max_len < 25) {
      return -1;
    }
    size += 25;
    source += 25;
    max_len -= 25;
  }
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 2) {
    return -1;
  }
  return size + 2;
}

size_t size_play_toclient_trade_list(play_toclient_trade_list packet) {
  size_t size = 0;
  size += size_varlong(packet.window_id);
  size += 1;
  for(size_t i_0 = 0; i_0 < packet.trades.count; ++i_0) {
    size += size_slot(packet.trades.base[i_0].input_item1);
    size += size_slot(packet.trades.base[i_0].output_item);
    size += 1;
    if(packet.trades.base[i_0].input_item2.opt) {
      size += size_slot(packet.trades.base[i_0].input_item2.val);
    }
    size += 25;
  }
  size += size_varlong(packet.villager_level);
  size += size_varlong(packet.experience);
  return size + 2;
}

char * dec_play_toclient_trade_list(play_toclient_trade_list *packet, char * source) {
  source = dec_varlong(&packet->window_id, source);
  source = dec_byte(&packet->trades.count, source);
  if(!(packet->trades.base = malloc(sizeof(*packet->trades.base) * packet->trades.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->trades.count; ++i_0) {
    if(!(source = dec_slot(&packet->trades.base[i_0].input_item1, source))) return NULL;
    if(!(source = dec_slot(&packet->trades.base[i_0].output_item, source))) return NULL;
    source = dec_byte(&packet->trades.base[i_0].input_item2.opt, source);
    if(packet->trades.base[i_0].input_item2.opt) {
      if(!(source = dec_slot(&packet->trades.base[i_0].input_item2.val, source))) return NULL;
    }
    source = dec_byte(&packet->trades.base[i_0].trade_disabled, source);
    source = dec_be32(&packet->trades.base[i_0].nb_trade_uses, source);
    source = dec_be32(&packet->trades.base[i_0].maximum_nb_trade_uses, source);
    source = dec_be32(&packet->trades.base[i_0].xp, source);
    source = dec_be32(&packet->trades.base[i_0].special_price, source);
    source = dec_bef32(&packet->trades.base[i_0].price_multiplier, source);
    source = dec_be32(&packet->trades.base[i_0].demand, source);
  }
  source = dec_varlong(&packet->villager_level, source);
  source = dec_varlong(&packet->experience, source);
  source = dec_byte(&packet->is_regular_villager, source);
  source = dec_byte(&packet->can_restock, source);
  return source;
}

char * enc_play_toclient_trade_list(char * dest, play_toclient_trade_list source) {
  dest = enc_varlong(dest, source.window_id);
  dest = enc_byte(dest, source.trades.count);
  for(size_t i_0 = 0; i_0 < source.trades.count; ++i_0) {
    dest = enc_slot(dest, source.trades.base[i_0].input_item1);
    dest = enc_slot(dest, source.trades.base[i_0].output_item);
    dest = enc_byte(dest, source.trades.base[i_0].input_item2.opt);
    if(source.trades.base[i_0].input_item2.opt) {
      dest = enc_slot(dest, source.trades.base[i_0].input_item2.val);
    }
    dest = enc_byte(dest, source.trades.base[i_0].trade_disabled);
    dest = enc_be32(dest, source.trades.base[i_0].nb_trade_uses);
    dest = enc_be32(dest, source.trades.base[i_0].maximum_nb_trade_uses);
    dest = enc_be32(dest, source.trades.base[i_0].xp);
    dest = enc_be32(dest, source.trades.base[i_0].special_price);
    dest = enc_bef32(dest, source.trades.base[i_0].price_multiplier);
    dest = enc_be32(dest, source.trades.base[i_0].demand);
  }
  dest = enc_varlong(dest, source.villager_level);
  dest = enc_varlong(dest, source.experience);
  dest = enc_byte(dest, source.is_regular_villager);
  dest = enc_byte(dest, source.can_restock);
  return dest;
}

void free_play_toclient_trade_list(play_toclient_trade_list packet) {
  for(size_t i_0 = 0; i_0 < packet.trades.count; ++i_0) {
    free_slot(packet.trades.base[i_0].input_item1);
    free_slot(packet.trades.base[i_0].output_item);
    if(packet.trades.base[i_0].input_item2.opt) {
      free_slot(packet.trades.base[i_0].input_item2.val);
    }
  }
  free(packet.trades.base);
}

int walk_play_toclient_rel_entity_move(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 7) {
    return -1;
  }
  return size + 7;
}

size_t size_play_toclient_rel_entity_move(play_toclient_rel_entity_move packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 7;
}

char * dec_play_toclient_rel_entity_move(play_toclient_rel_entity_move *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_be16(&packet->d_x, source);
  source = dec_be16(&packet->d_y, source);
  source = dec_be16(&packet->d_z, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toclient_rel_entity_move(char * dest, play_toclient_rel_entity_move source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_be16(dest, source.d_x);
  dest = enc_be16(dest, source.d_y);
  dest = enc_be16(dest, source.d_z);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toclient_entity_move_look(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 9) {
    return -1;
  }
  return size + 9;
}

size_t size_play_toclient_entity_move_look(play_toclient_entity_move_look packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 9;
}

char * dec_play_toclient_entity_move_look(play_toclient_entity_move_look *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_be16(&packet->d_x, source);
  source = dec_be16(&packet->d_y, source);
  source = dec_be16(&packet->d_z, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toclient_entity_move_look(char * dest, play_toclient_entity_move_look source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_be16(dest, source.d_x);
  dest = enc_be16(dest, source.d_y);
  dest = enc_be16(dest, source.d_z);
  dest = enc_byte(dest, source.yaw);
  dest = enc_byte(dest, source.pitch);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toclient_entity_look(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 3) {
    return -1;
  }
  return size + 3;
}

size_t size_play_toclient_entity_look(play_toclient_entity_look packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 3;
}

char * dec_play_toclient_entity_look(play_toclient_entity_look *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toclient_entity_look(char * dest, play_toclient_entity_look source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.yaw);
  dest = enc_byte(dest, source.pitch);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toclient_entity(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_entity(play_toclient_entity packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size;
}

char * dec_play_toclient_entity(play_toclient_entity *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  return source;
}

char * enc_play_toclient_entity(char * dest, play_toclient_entity source) {
  dest = enc_varlong(dest, source.entity_id);
  return dest;
}

int walk_play_toclient_vehicle_move(char * source, size_t max_len) {
  if(max_len < 32) return -1;
  return 32;
}

size_t size_play_toclient_vehicle_move(play_toclient_vehicle_move packet) {
  return 32;
}

char * dec_play_toclient_vehicle_move(play_toclient_vehicle_move *packet, char * source) {
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_bef32(&packet->yaw, source);
  source = dec_bef32(&packet->pitch, source);
  return source;
}

char * enc_play_toclient_vehicle_move(char * dest, play_toclient_vehicle_move source) {
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_bef32(dest, source.yaw);
  dest = enc_bef32(dest, source.pitch);
  return dest;
}

int walk_play_toclient_open_book(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_open_book(play_toclient_open_book packet) {
  size_t size = 0;
  size += size_varlong(packet.hand);
  return size;
}

char * dec_play_toclient_open_book(play_toclient_open_book *packet, char * source) {
  source = dec_varlong(&packet->hand, source);
  return source;
}

char * enc_play_toclient_open_book(char * dest, play_toclient_open_book source) {
  dest = enc_varlong(dest, source.hand);
  return dest;
}

int walk_play_toclient_open_sign_entity(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_play_toclient_open_sign_entity(play_toclient_open_sign_entity packet) {
  return 8;
}

char * dec_play_toclient_open_sign_entity(play_toclient_open_sign_entity *packet, char * source) {
  source = dec_position(&packet->location, source);
  return source;
}

char * enc_play_toclient_open_sign_entity(char * dest, play_toclient_open_sign_entity source) {
  dest = enc_position(dest, source.location);
  return dest;
}

int walk_play_toclient_craft_recipe_response(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_craft_recipe_response(play_toclient_craft_recipe_response packet) {
  size_t size = 0;
  size += 1;
  size += size_string(packet.recipe);
  return size;
}

char * dec_play_toclient_craft_recipe_response(play_toclient_craft_recipe_response *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  if(!(source = dec_string(&packet->recipe, source))) return NULL;
  return source;
}

char * enc_play_toclient_craft_recipe_response(char * dest, play_toclient_craft_recipe_response source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_string(dest, source.recipe);
  return dest;
}

void free_play_toclient_craft_recipe_response(play_toclient_craft_recipe_response packet) {
  free_string(packet.recipe);
}

int walk_play_toclient_abilities(char * source, size_t max_len) {
  if(max_len < 9) return -1;
  return 9;
}

size_t size_play_toclient_abilities(play_toclient_abilities packet) {
  return 9;
}

char * dec_play_toclient_abilities(play_toclient_abilities *packet, char * source) {
  source = dec_byte(&packet->flags, source);
  source = dec_bef32(&packet->flying_speed, source);
  source = dec_bef32(&packet->walking_speed, source);
  return source;
}

char * enc_play_toclient_abilities(char * dest, play_toclient_abilities source) {
  dest = enc_byte(dest, source.flags);
  dest = enc_bef32(dest, source.flying_speed);
  dest = enc_bef32(dest, source.walking_speed);
  return dest;
}

int walk_play_toclient_combat_event(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t event;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&event, source);
  switch(event) {
    case 1:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(event) {
    case 2:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(event) {
    case 2:
    case 1:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(event) {
    case 2:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  return size;
}

size_t size_play_toclient_combat_event(play_toclient_combat_event packet) {
  size_t size = 0;
  size += size_varlong(packet.event);
  switch(packet.event) {
    case 1:
      size += size_varlong(packet.duration);
      break;
  }
  switch(packet.event) {
    case 2:
      size += size_varlong(packet.player_id);
      break;
  }
  switch(packet.event) {
    case 2:
    case 1:
      size += 4;
      break;
  }
  switch(packet.event) {
    case 2:
      size += size_string(packet.message);
      break;
  }
  return size;
}

char * dec_play_toclient_combat_event(play_toclient_combat_event *packet, char * source) {
  source = dec_varlong(&packet->event, source);
  switch(packet->event) {
    case 1:
      source = dec_varlong(&packet->duration, source);
      break;
  }
  switch(packet->event) {
    case 2:
      source = dec_varlong(&packet->player_id, source);
      break;
  }
  switch(packet->event) {
    case 2:
    case 1:
      source = dec_be32(&packet->entity_id, source);
      break;
  }
  switch(packet->event) {
    case 2:
      if(!(source = dec_string(&packet->message, source))) return NULL;
      break;
  }
  return source;
}

char * enc_play_toclient_combat_event(char * dest, play_toclient_combat_event source) {
  dest = enc_varlong(dest, source.event);
  switch(source.event) {
    case 1:
      dest = enc_varlong(dest, source.duration);
      break;
  }
  switch(source.event) {
    case 2:
      dest = enc_varlong(dest, source.player_id);
      break;
  }
  switch(source.event) {
    case 2:
    case 1:
      dest = enc_be32(dest, source.entity_id);
      break;
  }
  switch(source.event) {
    case 2:
      dest = enc_string(dest, source.message);
      break;
  }
  return dest;
}

void free_play_toclient_combat_event(play_toclient_combat_event packet) {
  switch(packet.event) {
    case 2:
      free_string(packet.message);
      break;
  }
}

int walk_play_toclient_player_info(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t action;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&action, source);
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t data_count;
  source = dec_varlong(&data_count, source);
  for(size_t i_0 = 0; i_0 < data_count; ++i_0) {
    if(max_len < 16) {
      return -1;
    }
    size += 16;
    source += 16;
    max_len -= 16;
    switch(action) {
      case 0:
        if((ret = walk_string(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
        break;
    }
    switch(action) {
      case 0:
        if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        max_len -= ret;
        int64_t properties_count;
        source = dec_varlong(&properties_count, source);
        for(size_t i_3 = 0; i_3 < properties_count; ++i_3) {
          if((ret = walk_string(source, max_len)) < 0) {
            return -1;
          }
          size += ret;
          source += ret;
          max_len -= ret;
          if((ret = walk_string(source, max_len)) < 0) {
            return -1;
          }
          size += ret;
          source += ret;
          max_len -= ret;
          if(max_len < 1) {
              return -1;
          }
          uint8_t signature_opt;
          source = dec_byte(&signature_opt, source);
          size += 1;
          max_len -= 1;
          if(signature_opt) {
            if((ret = walk_string(source, max_len)) < 0) {
              return -1;
            }
            size += ret;
            source += ret;
            max_len -= ret;
          }
        }
        break;
    }
    switch(action) {
      case 1:
      case 0:
        if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
        break;
    }
    switch(action) {
      case 2:
      case 0:
        if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
        break;
    }
    switch(action) {
      case 3:
      case 0:
        if(max_len < 1) {
            return -1;
        }
        uint8_t display_name_opt;
        source = dec_byte(&display_name_opt, source);
        size += 1;
        max_len -= 1;
        if(display_name_opt) {
          if((ret = walk_string(source, max_len)) < 0) {
            return -1;
          }
          size += ret;
          source += ret;
          max_len -= ret;
        }
        break;
    }
  }
  return size;
}

size_t size_play_toclient_player_info(play_toclient_player_info packet) {
  size_t size = 0;
  size += size_varlong(packet.action);
  size += size_varlong(packet.data.count);
  for(size_t i_0 = 0; i_0 < packet.data.count; ++i_0) {
    size += 16;
    switch(packet.action) {
      case 0:
        size += size_string(packet.data.base[i_0].name);
        break;
    }
    switch(packet.action) {
      case 0:
        size += size_varlong(packet.data.base[i_0].properties.count);
        for(size_t i_3 = 0; i_3 < packet.data.base[i_0].properties.count; ++i_3) {
          size += size_string(packet.data.base[i_0].properties.base[i_3].name);
          size += size_string(packet.data.base[i_0].properties.base[i_3].value);
          size += 1;
          if(packet.data.base[i_0].properties.base[i_3].signature.opt) {
            size += size_string(packet.data.base[i_0].properties.base[i_3].signature.val);
          }
        }
        break;
    }
    switch(packet.action) {
      case 1:
      case 0:
        size += size_varlong(packet.data.base[i_0].gamemode);
        break;
    }
    switch(packet.action) {
      case 2:
      case 0:
        size += size_varlong(packet.data.base[i_0].ping);
        break;
    }
    switch(packet.action) {
      case 3:
      case 0:
        size += 1;
        if(packet.data.base[i_0].display_name.opt) {
          size += size_string(packet.data.base[i_0].display_name.val);
        }
        break;
    }
  }
  return size;
}

char * dec_play_toclient_player_info(play_toclient_player_info *packet, char * source) {
  source = dec_varlong(&packet->action, source);
  source = dec_varlong(&packet->data.count, source);
  if(!(packet->data.base = malloc(sizeof(*packet->data.base) * packet->data.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->data.count; ++i_0) {
    source = dec_uuid(&packet->data.base[i_0].uuid, source);
    switch(packet->action) {
      case 0:
        if(!(source = dec_string(&packet->data.base[i_0].name, source))) return NULL;
        break;
    }
    switch(packet->action) {
      case 0:
        source = dec_varlong(&packet->data.base[i_0].properties.count, source);
        if(!(packet->data.base[i_0].properties.base = malloc(sizeof(*packet->data.base[i_0].properties.base) * packet->data.base[i_0].properties.count))) return NULL;
        for(size_t i_3 = 0; i_3 < packet->data.base[i_0].properties.count; ++i_3) {
          if(!(source = dec_string(&packet->data.base[i_0].properties.base[i_3].name, source))) return NULL;
          if(!(source = dec_string(&packet->data.base[i_0].properties.base[i_3].value, source))) return NULL;
          source = dec_byte(&packet->data.base[i_0].properties.base[i_3].signature.opt, source);
          if(packet->data.base[i_0].properties.base[i_3].signature.opt) {
            if(!(source = dec_string(&packet->data.base[i_0].properties.base[i_3].signature.val, source))) return NULL;
          }
        }
        break;
    }
    switch(packet->action) {
      case 1:
      case 0:
        source = dec_varlong(&packet->data.base[i_0].gamemode, source);
        break;
    }
    switch(packet->action) {
      case 2:
      case 0:
        source = dec_varlong(&packet->data.base[i_0].ping, source);
        break;
    }
    switch(packet->action) {
      case 3:
      case 0:
        source = dec_byte(&packet->data.base[i_0].display_name.opt, source);
        if(packet->data.base[i_0].display_name.opt) {
          if(!(source = dec_string(&packet->data.base[i_0].display_name.val, source))) return NULL;
        }
        break;
    }
  }
  return source;
}

char * enc_play_toclient_player_info(char * dest, play_toclient_player_info source) {
  dest = enc_varlong(dest, source.action);
  dest = enc_varlong(dest, source.data.count);
  for(size_t i_0 = 0; i_0 < source.data.count; ++i_0) {
    dest = enc_uuid(dest, source.data.base[i_0].uuid);
    switch(source.action) {
      case 0:
        dest = enc_string(dest, source.data.base[i_0].name);
        break;
    }
    switch(source.action) {
      case 0:
        dest = enc_varlong(dest, source.data.base[i_0].properties.count);
        for(size_t i_3 = 0; i_3 < source.data.base[i_0].properties.count; ++i_3) {
          dest = enc_string(dest, source.data.base[i_0].properties.base[i_3].name);
          dest = enc_string(dest, source.data.base[i_0].properties.base[i_3].value);
          dest = enc_byte(dest, source.data.base[i_0].properties.base[i_3].signature.opt);
          if(source.data.base[i_0].properties.base[i_3].signature.opt) {
            dest = enc_string(dest, source.data.base[i_0].properties.base[i_3].signature.val);
          }
        }
        break;
    }
    switch(source.action) {
      case 1:
      case 0:
        dest = enc_varlong(dest, source.data.base[i_0].gamemode);
        break;
    }
    switch(source.action) {
      case 2:
      case 0:
        dest = enc_varlong(dest, source.data.base[i_0].ping);
        break;
    }
    switch(source.action) {
      case 3:
      case 0:
        dest = enc_byte(dest, source.data.base[i_0].display_name.opt);
        if(source.data.base[i_0].display_name.opt) {
          dest = enc_string(dest, source.data.base[i_0].display_name.val);
        }
        break;
    }
  }
  return dest;
}

void free_play_toclient_player_info(play_toclient_player_info packet) {
  for(size_t i_0 = 0; i_0 < packet.data.count; ++i_0) {
    switch(packet.action) {
      case 0:
        free_string(packet.data.base[i_0].name);
        break;
    }
    switch(packet.action) {
      case 0:
        for(size_t i_3 = 0; i_3 < packet.data.base[i_0].properties.count; ++i_3) {
          free_string(packet.data.base[i_0].properties.base[i_3].name);
          free_string(packet.data.base[i_0].properties.base[i_3].value);
          if(packet.data.base[i_0].properties.base[i_3].signature.opt) {
            free_string(packet.data.base[i_0].properties.base[i_3].signature.val);
          }
        }
        free(packet.data.base[i_0].properties.base);
        break;
    }
    switch(packet.action) {
      case 3:
      case 0:
        if(packet.data.base[i_0].display_name.opt) {
          free_string(packet.data.base[i_0].display_name.val);
        }
        break;
    }
  }
  free(packet.data.base);
}

int walk_play_toclient_position(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 33) {
    return -1;
  }
  size += 33;
  source += 33;
  max_len -= 33;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_position(play_toclient_position packet) {
  size_t size = 0;
  size += 33;
  size += size_varlong(packet.teleport_id);
  return size;
}

char * dec_play_toclient_position(play_toclient_position *packet, char * source) {
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_bef32(&packet->yaw, source);
  source = dec_bef32(&packet->pitch, source);
  source = dec_byte(&packet->flags, source);
  source = dec_varlong(&packet->teleport_id, source);
  return source;
}

char * enc_play_toclient_position(char * dest, play_toclient_position source) {
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_bef32(dest, source.yaw);
  dest = enc_bef32(dest, source.pitch);
  dest = enc_byte(dest, source.flags);
  dest = enc_varlong(dest, source.teleport_id);
  return dest;
}

int walk_play_toclient_unlock_recipes(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t action;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&action, source);
  if(max_len < 4) {
      return -1;
  }
  size += 4;
  source += 4;
  max_len -= 4;
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t recipes1_count;
  source = dec_varlong(&recipes1_count, source);
  for(size_t i_0 = 0; i_0 < recipes1_count; ++i_0) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  switch(action) {
    case 0:
      if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
      }
      size += ret;
      max_len -= ret;
      int64_t recipes2_count;
      source = dec_varlong(&recipes2_count, source);
      for(size_t i_1 = 0; i_1 < recipes2_count; ++i_1) {
        if((ret = walk_string(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
      }
      break;
  }
  return size;
}

size_t size_play_toclient_unlock_recipes(play_toclient_unlock_recipes packet) {
  size_t size = 0;
  size += size_varlong(packet.action);
  size += 4;
  size += size_varlong(packet.recipes1.count);
  for(size_t i_0 = 0; i_0 < packet.recipes1.count; ++i_0) {
    size += size_string(packet.recipes1.base[i_0]);
  }
  switch(packet.action) {
    case 0:
      size += size_varlong(packet.recipes2.count);
      for(size_t i_1 = 0; i_1 < packet.recipes2.count; ++i_1) {
        size += size_string(packet.recipes2.base[i_1]);
      }
      break;
  }
  return size;
}

char * dec_play_toclient_unlock_recipes(play_toclient_unlock_recipes *packet, char * source) {
  source = dec_varlong(&packet->action, source);
  source = dec_byte(&packet->crafting_book_open, source);
  source = dec_byte(&packet->filtering_craftable, source);
  source = dec_byte(&packet->smelting_book_open, source);
  source = dec_byte(&packet->filtering_smeltable, source);
  source = dec_varlong(&packet->recipes1.count, source);
  if(!(packet->recipes1.base = malloc(sizeof(*packet->recipes1.base) * packet->recipes1.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->recipes1.count; ++i_0) {
    if(!(source = dec_string(&packet->recipes1.base[i_0], source))) return NULL;
  }
  switch(packet->action) {
    case 0:
      source = dec_varlong(&packet->recipes2.count, source);
      if(!(packet->recipes2.base = malloc(sizeof(*packet->recipes2.base) * packet->recipes2.count))) return NULL;
      for(size_t i_1 = 0; i_1 < packet->recipes2.count; ++i_1) {
        if(!(source = dec_string(&packet->recipes2.base[i_1], source))) return NULL;
      }
      break;
  }
  return source;
}

char * enc_play_toclient_unlock_recipes(char * dest, play_toclient_unlock_recipes source) {
  dest = enc_varlong(dest, source.action);
  dest = enc_byte(dest, source.crafting_book_open);
  dest = enc_byte(dest, source.filtering_craftable);
  dest = enc_byte(dest, source.smelting_book_open);
  dest = enc_byte(dest, source.filtering_smeltable);
  dest = enc_varlong(dest, source.recipes1.count);
  for(size_t i_0 = 0; i_0 < source.recipes1.count; ++i_0) {
    dest = enc_string(dest, source.recipes1.base[i_0]);
  }
  switch(source.action) {
    case 0:
      dest = enc_varlong(dest, source.recipes2.count);
      for(size_t i_1 = 0; i_1 < source.recipes2.count; ++i_1) {
        dest = enc_string(dest, source.recipes2.base[i_1]);
      }
      break;
  }
  return dest;
}

void free_play_toclient_unlock_recipes(play_toclient_unlock_recipes packet) {
  for(size_t i_0 = 0; i_0 < packet.recipes1.count; ++i_0) {
    free_string(packet.recipes1.base[i_0]);
  }
  free(packet.recipes1.base);
  switch(packet.action) {
    case 0:
      for(size_t i_1 = 0; i_1 < packet.recipes2.count; ++i_1) {
        free_string(packet.recipes2.base[i_1]);
      }
      free(packet.recipes2.base);
      break;
  }
}

int walk_play_toclient_entity_destroy(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t entity_ids_count;
  source = dec_varlong(&entity_ids_count, source);
  for(size_t i_0 = 0; i_0 < entity_ids_count; ++i_0) {
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_entity_destroy(play_toclient_entity_destroy packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_ids.count);
  for(size_t i_0 = 0; i_0 < packet.entity_ids.count; ++i_0) {
    size += size_varlong(packet.entity_ids.base[i_0]);
  }
  return size;
}

char * dec_play_toclient_entity_destroy(play_toclient_entity_destroy *packet, char * source) {
  source = dec_varlong(&packet->entity_ids.count, source);
  if(!(packet->entity_ids.base = malloc(sizeof(*packet->entity_ids.base) * packet->entity_ids.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->entity_ids.count; ++i_0) {
    source = dec_varlong(&packet->entity_ids.base[i_0], source);
  }
  return source;
}

char * enc_play_toclient_entity_destroy(char * dest, play_toclient_entity_destroy source) {
  dest = enc_varlong(dest, source.entity_ids.count);
  for(size_t i_0 = 0; i_0 < source.entity_ids.count; ++i_0) {
    dest = enc_varlong(dest, source.entity_ids.base[i_0]);
  }
  return dest;
}

void free_play_toclient_entity_destroy(play_toclient_entity_destroy packet) {
  free(packet.entity_ids.base);
}

int walk_play_toclient_remove_entity_effect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_remove_entity_effect(play_toclient_remove_entity_effect packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 1;
}

char * dec_play_toclient_remove_entity_effect(play_toclient_remove_entity_effect *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->effect_id, source);
  return source;
}

char * enc_play_toclient_remove_entity_effect(char * dest, play_toclient_remove_entity_effect source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.effect_id);
  return dest;
}

int walk_play_toclient_resource_pack_send(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_resource_pack_send(play_toclient_resource_pack_send packet) {
  size_t size = 0;
  size += size_string(packet.url);
  size += size_string(packet.hash);
  return size;
}

char * dec_play_toclient_resource_pack_send(play_toclient_resource_pack_send *packet, char * source) {
  if(!(source = dec_string(&packet->url, source))) return NULL;
  if(!(source = dec_string(&packet->hash, source))) return NULL;
  return source;
}

char * enc_play_toclient_resource_pack_send(char * dest, play_toclient_resource_pack_send source) {
  dest = enc_string(dest, source.url);
  dest = enc_string(dest, source.hash);
  return dest;
}

void free_play_toclient_resource_pack_send(play_toclient_resource_pack_send packet) {
  free_string(packet.url);
  free_string(packet.hash);
}

int walk_play_toclient_respawn(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 5) {
    return -1;
  }
  size += 5;
  source += 5;
  max_len -= 5;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_respawn(play_toclient_respawn packet) {
  size_t size = 0;
  size += 5;
  size += size_string(packet.level_type);
  return size;
}

char * dec_play_toclient_respawn(play_toclient_respawn *packet, char * source) {
  source = dec_be32(&packet->dimension, source);
  source = dec_byte(&packet->gamemode, source);
  if(!(source = dec_string(&packet->level_type, source))) return NULL;
  return source;
}

char * enc_play_toclient_respawn(char * dest, play_toclient_respawn source) {
  dest = enc_be32(dest, source.dimension);
  dest = enc_byte(dest, source.gamemode);
  dest = enc_string(dest, source.level_type);
  return dest;
}

void free_play_toclient_respawn(play_toclient_respawn packet) {
  free_string(packet.level_type);
}

int walk_play_toclient_entity_update_attributes(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  max_len -= 4;
  int32_t properties_count;
  source = dec_be32(&properties_count, source);
  for(size_t i_0 = 0; i_0 < properties_count; ++i_0) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if(max_len < 8) {
      return -1;
    }
    size += 8;
    source += 8;
    max_len -= 8;
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    max_len -= ret;
    int64_t modifiers_count;
    source = dec_varlong(&modifiers_count, source);
    if(max_len < modifiers_count * 25) {
      return -1;
    }
    size += modifiers_count * 25;
    source += modifiers_count * 25;
    max_len -= modifiers_count * 25;
  }
  return size;
}

size_t size_play_toclient_entity_update_attributes(play_toclient_entity_update_attributes packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 4;
  for(size_t i_0 = 0; i_0 < packet.properties.count; ++i_0) {
    size += size_string(packet.properties.base[i_0].key);
    size += 8;
    size += size_varlong(packet.properties.base[i_0].modifiers.count);
    size += packet.properties.base[i_0].modifiers.count * 25;
  }
  return size;
}

char * dec_play_toclient_entity_update_attributes(play_toclient_entity_update_attributes *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_be32(&packet->properties.count, source);
  if(!(packet->properties.base = malloc(sizeof(*packet->properties.base) * packet->properties.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->properties.count; ++i_0) {
    if(!(source = dec_string(&packet->properties.base[i_0].key, source))) return NULL;
    source = dec_bef64(&packet->properties.base[i_0].value, source);
    source = dec_varlong(&packet->properties.base[i_0].modifiers.count, source);
    if(!(packet->properties.base[i_0].modifiers.base = malloc(sizeof(*packet->properties.base[i_0].modifiers.base) * packet->properties.base[i_0].modifiers.count))) return NULL;
    for(size_t i_2 = 0; i_2 < packet->properties.base[i_0].modifiers.count; ++i_2) {
      source = dec_uuid(&packet->properties.base[i_0].modifiers.base[i_2].uuid, source);
      source = dec_bef64(&packet->properties.base[i_0].modifiers.base[i_2].amount, source);
      source = dec_byte(&packet->properties.base[i_0].modifiers.base[i_2].operation, source);
    }
  }
  return source;
}

char * enc_play_toclient_entity_update_attributes(char * dest, play_toclient_entity_update_attributes source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_be32(dest, source.properties.count);
  for(size_t i_0 = 0; i_0 < source.properties.count; ++i_0) {
    dest = enc_string(dest, source.properties.base[i_0].key);
    dest = enc_bef64(dest, source.properties.base[i_0].value);
    dest = enc_varlong(dest, source.properties.base[i_0].modifiers.count);
    for(size_t i_2 = 0; i_2 < source.properties.base[i_0].modifiers.count; ++i_2) {
      dest = enc_uuid(dest, source.properties.base[i_0].modifiers.base[i_2].uuid);
      dest = enc_bef64(dest, source.properties.base[i_0].modifiers.base[i_2].amount);
      dest = enc_byte(dest, source.properties.base[i_0].modifiers.base[i_2].operation);
    }
  }
  return dest;
}

void free_play_toclient_entity_update_attributes(play_toclient_entity_update_attributes packet) {
  for(size_t i_0 = 0; i_0 < packet.properties.count; ++i_0) {
    free_string(packet.properties.base[i_0].key);
    free(packet.properties.base[i_0].modifiers.base);
  }
  free(packet.properties.base);
}

int walk_play_toclient_world_border(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t action;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&action, source);
  switch(action) {
    case 0:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  switch(action) {
    case 3:
    case 2:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  switch(action) {
    case 3:
    case 2:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  switch(action) {
    case 3:
    case 1:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  switch(action) {
    case 3:
    case 1:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  switch(action) {
    case 3:
    case 1:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 3:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 4:
    case 3:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 5:
    case 3:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  return size;
}

size_t size_play_toclient_world_border(play_toclient_world_border packet) {
  size_t size = 0;
  size += size_varlong(packet.action);
  switch(packet.action) {
    case 0:
      size += 8;
      break;
  }
  switch(packet.action) {
    case 3:
    case 2:
      size += 8;
      break;
  }
  switch(packet.action) {
    case 3:
    case 2:
      size += 8;
      break;
  }
  switch(packet.action) {
    case 3:
    case 1:
      size += 8;
      break;
  }
  switch(packet.action) {
    case 3:
    case 1:
      size += 8;
      break;
  }
  switch(packet.action) {
    case 3:
    case 1:
      size += size_varlong(packet.speed);
      break;
  }
  switch(packet.action) {
    case 3:
      size += size_varlong(packet.portal_boundary);
      break;
  }
  switch(packet.action) {
    case 4:
    case 3:
      size += size_varlong(packet.warning_time);
      break;
  }
  switch(packet.action) {
    case 5:
    case 3:
      size += size_varlong(packet.warning_blocks);
      break;
  }
  return size;
}

char * dec_play_toclient_world_border(play_toclient_world_border *packet, char * source) {
  source = dec_varlong(&packet->action, source);
  switch(packet->action) {
    case 0:
      source = dec_bef64(&packet->radius, source);
      break;
  }
  switch(packet->action) {
    case 3:
    case 2:
      source = dec_bef64(&packet->x, source);
      break;
  }
  switch(packet->action) {
    case 3:
    case 2:
      source = dec_bef64(&packet->z, source);
      break;
  }
  switch(packet->action) {
    case 3:
    case 1:
      source = dec_bef64(&packet->old_radius, source);
      break;
  }
  switch(packet->action) {
    case 3:
    case 1:
      source = dec_bef64(&packet->new_radius, source);
      break;
  }
  switch(packet->action) {
    case 3:
    case 1:
      source = dec_varlong(&packet->speed, source);
      break;
  }
  switch(packet->action) {
    case 3:
      source = dec_varlong(&packet->portal_boundary, source);
      break;
  }
  switch(packet->action) {
    case 4:
    case 3:
      source = dec_varlong(&packet->warning_time, source);
      break;
  }
  switch(packet->action) {
    case 5:
    case 3:
      source = dec_varlong(&packet->warning_blocks, source);
      break;
  }
  return source;
}

char * enc_play_toclient_world_border(char * dest, play_toclient_world_border source) {
  dest = enc_varlong(dest, source.action);
  switch(source.action) {
    case 0:
      dest = enc_bef64(dest, source.radius);
      break;
  }
  switch(source.action) {
    case 3:
    case 2:
      dest = enc_bef64(dest, source.x);
      break;
  }
  switch(source.action) {
    case 3:
    case 2:
      dest = enc_bef64(dest, source.z);
      break;
  }
  switch(source.action) {
    case 3:
    case 1:
      dest = enc_bef64(dest, source.old_radius);
      break;
  }
  switch(source.action) {
    case 3:
    case 1:
      dest = enc_bef64(dest, source.new_radius);
      break;
  }
  switch(source.action) {
    case 3:
    case 1:
      dest = enc_varlong(dest, source.speed);
      break;
  }
  switch(source.action) {
    case 3:
      dest = enc_varlong(dest, source.portal_boundary);
      break;
  }
  switch(source.action) {
    case 4:
    case 3:
      dest = enc_varlong(dest, source.warning_time);
      break;
  }
  switch(source.action) {
    case 5:
    case 3:
      dest = enc_varlong(dest, source.warning_blocks);
      break;
  }
  return dest;
}

int walk_play_toclient_camera(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_camera(play_toclient_camera packet) {
  size_t size = 0;
  size += size_varlong(packet.camera_id);
  return size;
}

char * dec_play_toclient_camera(play_toclient_camera *packet, char * source) {
  source = dec_varlong(&packet->camera_id, source);
  return source;
}

char * enc_play_toclient_camera(char * dest, play_toclient_camera source) {
  dest = enc_varlong(dest, source.camera_id);
  return dest;
}

int walk_play_toclient_held_item_slot(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toclient_held_item_slot(play_toclient_held_item_slot packet) {
  return 1;
}

char * dec_play_toclient_held_item_slot(play_toclient_held_item_slot *packet, char * source) {
  source = dec_byte(&packet->slot, source);
  return source;
}

char * enc_play_toclient_held_item_slot(char * dest, play_toclient_held_item_slot source) {
  dest = enc_byte(dest, source.slot);
  return dest;
}

int walk_play_toclient_update_view_position(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_update_view_position(play_toclient_update_view_position packet) {
  size_t size = 0;
  size += size_varlong(packet.chunk_x);
  size += size_varlong(packet.chunk_z);
  return size;
}

char * dec_play_toclient_update_view_position(play_toclient_update_view_position *packet, char * source) {
  source = dec_varlong(&packet->chunk_x, source);
  source = dec_varlong(&packet->chunk_z, source);
  return source;
}

char * enc_play_toclient_update_view_position(char * dest, play_toclient_update_view_position source) {
  dest = enc_varlong(dest, source.chunk_x);
  dest = enc_varlong(dest, source.chunk_z);
  return dest;
}

int walk_play_toclient_update_view_distance(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_update_view_distance(play_toclient_update_view_distance packet) {
  size_t size = 0;
  size += size_varlong(packet.view_distance);
  return size;
}

char * dec_play_toclient_update_view_distance(play_toclient_update_view_distance *packet, char * source) {
  source = dec_varlong(&packet->view_distance, source);
  return source;
}

char * enc_play_toclient_update_view_distance(char * dest, play_toclient_update_view_distance source) {
  dest = enc_varlong(dest, source.view_distance);
  return dest;
}

int walk_play_toclient_scoreboard_display_objective(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_scoreboard_display_objective(play_toclient_scoreboard_display_objective packet) {
  size_t size = 0;
  size += 1;
  size += size_string(packet.name);
  return size;
}

char * dec_play_toclient_scoreboard_display_objective(play_toclient_scoreboard_display_objective *packet, char * source) {
  source = dec_byte(&packet->position, source);
  if(!(source = dec_string(&packet->name, source))) return NULL;
  return source;
}

char * enc_play_toclient_scoreboard_display_objective(char * dest, play_toclient_scoreboard_display_objective source) {
  dest = enc_byte(dest, source.position);
  dest = enc_string(dest, source.name);
  return dest;
}

void free_play_toclient_scoreboard_display_objective(play_toclient_scoreboard_display_objective packet) {
  free_string(packet.name);
}

int walk_play_toclient_entity_metadata(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_metadata(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_entity_metadata(play_toclient_entity_metadata packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += size_metadata(packet.metadata);
  return size;
}

char * dec_play_toclient_entity_metadata(play_toclient_entity_metadata *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  if(!(source = dec_metadata(&packet->metadata, source))) return NULL;
  return source;
}

char * enc_play_toclient_entity_metadata(char * dest, play_toclient_entity_metadata source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_metadata(dest, source.metadata);
  return dest;
}

void free_play_toclient_entity_metadata(play_toclient_entity_metadata packet) {
  free_metadata(packet.metadata);
}

int walk_play_toclient_attach_entity(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_play_toclient_attach_entity(play_toclient_attach_entity packet) {
  return 8;
}

char * dec_play_toclient_attach_entity(play_toclient_attach_entity *packet, char * source) {
  source = dec_be32(&packet->entity_id, source);
  source = dec_be32(&packet->vehicle_id, source);
  return source;
}

char * enc_play_toclient_attach_entity(char * dest, play_toclient_attach_entity source) {
  dest = enc_be32(dest, source.entity_id);
  dest = enc_be32(dest, source.vehicle_id);
  return dest;
}

int walk_play_toclient_entity_velocity(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 6) {
    return -1;
  }
  return size + 6;
}

size_t size_play_toclient_entity_velocity(play_toclient_entity_velocity packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 6;
}

char * dec_play_toclient_entity_velocity(play_toclient_entity_velocity *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_be16(&packet->velocity_x, source);
  source = dec_be16(&packet->velocity_y, source);
  source = dec_be16(&packet->velocity_z, source);
  return source;
}

char * enc_play_toclient_entity_velocity(char * dest, play_toclient_entity_velocity source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_be16(dest, source.velocity_x);
  dest = enc_be16(dest, source.velocity_y);
  dest = enc_be16(dest, source.velocity_z);
  return dest;
}

int walk_play_toclient_entity_equipment(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_slot(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_entity_equipment(play_toclient_entity_equipment packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += size_varlong(packet.slot);
  size += size_slot(packet.item);
  return size;
}

char * dec_play_toclient_entity_equipment(play_toclient_entity_equipment *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_varlong(&packet->slot, source);
  if(!(source = dec_slot(&packet->item, source))) return NULL;
  return source;
}

char * enc_play_toclient_entity_equipment(char * dest, play_toclient_entity_equipment source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_varlong(dest, source.slot);
  dest = enc_slot(dest, source.item);
  return dest;
}

void free_play_toclient_entity_equipment(play_toclient_entity_equipment packet) {
  free_slot(packet.item);
}

int walk_play_toclient_experience(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  source += 4;
  max_len -= 4;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_experience(play_toclient_experience packet) {
  size_t size = 0;
  size += 4;
  size += size_varlong(packet.level);
  size += size_varlong(packet.total_experience);
  return size;
}

char * dec_play_toclient_experience(play_toclient_experience *packet, char * source) {
  source = dec_bef32(&packet->experience_bar, source);
  source = dec_varlong(&packet->level, source);
  source = dec_varlong(&packet->total_experience, source);
  return source;
}

char * enc_play_toclient_experience(char * dest, play_toclient_experience source) {
  dest = enc_bef32(dest, source.experience_bar);
  dest = enc_varlong(dest, source.level);
  dest = enc_varlong(dest, source.total_experience);
  return dest;
}

int walk_play_toclient_update_health(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  source += 4;
  max_len -= 4;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 4) {
    return -1;
  }
  return size + 4;
}

size_t size_play_toclient_update_health(play_toclient_update_health packet) {
  size_t size = 0;
  size += 4;
  size += size_varlong(packet.food);
  return size + 4;
}

char * dec_play_toclient_update_health(play_toclient_update_health *packet, char * source) {
  source = dec_bef32(&packet->health, source);
  source = dec_varlong(&packet->food, source);
  source = dec_bef32(&packet->food_saturation, source);
  return source;
}

char * enc_play_toclient_update_health(char * dest, play_toclient_update_health source) {
  dest = enc_bef32(dest, source.health);
  dest = enc_varlong(dest, source.food);
  dest = enc_bef32(dest, source.food_saturation);
  return dest;
}

int walk_play_toclient_scoreboard_objective(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  int8_t action;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  max_len -= 1;
  source = dec_byte(&action, source);
  switch(action) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 2:
    case 0:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  return size;
}

size_t size_play_toclient_scoreboard_objective(play_toclient_scoreboard_objective packet) {
  size_t size = 0;
  size += size_string(packet.name);
  size += 1;
  switch(packet.action) {
    case 2:
    case 0:
      size += size_string(packet.display_text);
      break;
  }
  switch(packet.action) {
    case 2:
    case 0:
      size += size_varlong(packet.type);
      break;
  }
  return size;
}

char * dec_play_toclient_scoreboard_objective(play_toclient_scoreboard_objective *packet, char * source) {
  if(!(source = dec_string(&packet->name, source))) return NULL;
  source = dec_byte(&packet->action, source);
  switch(packet->action) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->display_text, source))) return NULL;
      break;
  }
  switch(packet->action) {
    case 2:
    case 0:
      source = dec_varlong(&packet->type, source);
      break;
  }
  return source;
}

char * enc_play_toclient_scoreboard_objective(char * dest, play_toclient_scoreboard_objective source) {
  dest = enc_string(dest, source.name);
  dest = enc_byte(dest, source.action);
  switch(source.action) {
    case 2:
    case 0:
      dest = enc_string(dest, source.display_text);
      break;
  }
  switch(source.action) {
    case 2:
    case 0:
      dest = enc_varlong(dest, source.type);
      break;
  }
  return dest;
}

void free_play_toclient_scoreboard_objective(play_toclient_scoreboard_objective packet) {
  free_string(packet.name);
  switch(packet.action) {
    case 2:
    case 0:
      free_string(packet.display_text);
      break;
  }
}

int walk_play_toclient_set_passengers(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t passengers_count;
  source = dec_varlong(&passengers_count, source);
  for(size_t i_0 = 0; i_0 < passengers_count; ++i_0) {
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_set_passengers(play_toclient_set_passengers packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += size_varlong(packet.passengers.count);
  for(size_t i_0 = 0; i_0 < packet.passengers.count; ++i_0) {
    size += size_varlong(packet.passengers.base[i_0]);
  }
  return size;
}

char * dec_play_toclient_set_passengers(play_toclient_set_passengers *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_varlong(&packet->passengers.count, source);
  if(!(packet->passengers.base = malloc(sizeof(*packet->passengers.base) * packet->passengers.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->passengers.count; ++i_0) {
    source = dec_varlong(&packet->passengers.base[i_0], source);
  }
  return source;
}

char * enc_play_toclient_set_passengers(char * dest, play_toclient_set_passengers source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_varlong(dest, source.passengers.count);
  for(size_t i_0 = 0; i_0 < source.passengers.count; ++i_0) {
    dest = enc_varlong(dest, source.passengers.base[i_0]);
  }
  return dest;
}

void free_play_toclient_set_passengers(play_toclient_set_passengers packet) {
  free(packet.passengers.base);
}

int walk_play_toclient_teams(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  int8_t mode;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  max_len -= 1;
  source = dec_byte(&mode, source);
  switch(mode) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if(max_len < 1) {
        return -1;
      }
      size += 1;
      source += 1;
      max_len -= 1;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(mode) {
    case 4:
    case 3:
    case 0:
      if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
      }
      size += ret;
      max_len -= ret;
      int64_t players_count;
      source = dec_varlong(&players_count, source);
      for(size_t i_1 = 0; i_1 < players_count; ++i_1) {
        if((ret = walk_string(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
      }
      break;
  }
  return size;
}

size_t size_play_toclient_teams(play_toclient_teams packet) {
  size_t size = 0;
  size += size_string(packet.team);
  size += 1;
  switch(packet.mode) {
    case 2:
    case 0:
      size += size_string(packet.name);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += 1;
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += size_string(packet.name_tag_visibility);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += size_string(packet.collision_rule);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += size_varlong(packet.formatting);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += size_string(packet.prefix);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += size_string(packet.suffix);
      break;
  }
  switch(packet.mode) {
    case 4:
    case 3:
    case 0:
      size += size_varlong(packet.players.count);
      for(size_t i_1 = 0; i_1 < packet.players.count; ++i_1) {
        size += size_string(packet.players.base[i_1]);
      }
      break;
  }
  return size;
}

char * dec_play_toclient_teams(play_toclient_teams *packet, char * source) {
  if(!(source = dec_string(&packet->team, source))) return NULL;
  source = dec_byte(&packet->mode, source);
  switch(packet->mode) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->name, source))) return NULL;
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      source = dec_byte(&packet->friendly_fire, source);
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->name_tag_visibility, source))) return NULL;
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->collision_rule, source))) return NULL;
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      source = dec_varlong(&packet->formatting, source);
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->prefix, source))) return NULL;
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->suffix, source))) return NULL;
      break;
  }
  switch(packet->mode) {
    case 4:
    case 3:
    case 0:
      source = dec_varlong(&packet->players.count, source);
      if(!(packet->players.base = malloc(sizeof(*packet->players.base) * packet->players.count))) return NULL;
      for(size_t i_1 = 0; i_1 < packet->players.count; ++i_1) {
        if(!(source = dec_string(&packet->players.base[i_1], source))) return NULL;
      }
      break;
  }
  return source;
}

char * enc_play_toclient_teams(char * dest, play_toclient_teams source) {
  dest = enc_string(dest, source.team);
  dest = enc_byte(dest, source.mode);
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_string(dest, source.name);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_byte(dest, source.friendly_fire);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_string(dest, source.name_tag_visibility);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_string(dest, source.collision_rule);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_varlong(dest, source.formatting);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_string(dest, source.prefix);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_string(dest, source.suffix);
      break;
  }
  switch(source.mode) {
    case 4:
    case 3:
    case 0:
      dest = enc_varlong(dest, source.players.count);
      for(size_t i_1 = 0; i_1 < source.players.count; ++i_1) {
        dest = enc_string(dest, source.players.base[i_1]);
      }
      break;
  }
  return dest;
}

void free_play_toclient_teams(play_toclient_teams packet) {
  free_string(packet.team);
  switch(packet.mode) {
    case 2:
    case 0:
      free_string(packet.name);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      free_string(packet.name_tag_visibility);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      free_string(packet.collision_rule);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      free_string(packet.prefix);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      free_string(packet.suffix);
      break;
  }
  switch(packet.mode) {
    case 4:
    case 3:
    case 0:
      for(size_t i_1 = 0; i_1 < packet.players.count; ++i_1) {
        free_string(packet.players.base[i_1]);
      }
      free(packet.players.base);
      break;
  }
}

int walk_play_toclient_scoreboard_score(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  int8_t action;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  max_len -= 1;
  source = dec_byte(&action, source);
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  switch(action) {
    case 1:
      // void condition
      break;
    default:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_scoreboard_score(play_toclient_scoreboard_score packet) {
  size_t size = 0;
  size += size_string(packet.item_name);
  size += 1;
  size += size_string(packet.score_name);
  switch(packet.action) {
    case 1:
      // void condition
      break;
    default:
      size += size_varlong(packet.value);
  }
  return size;
}

char * dec_play_toclient_scoreboard_score(play_toclient_scoreboard_score *packet, char * source) {
  if(!(source = dec_string(&packet->item_name, source))) return NULL;
  source = dec_byte(&packet->action, source);
  if(!(source = dec_string(&packet->score_name, source))) return NULL;
  switch(packet->action) {
    case 1:
      // void condition
      break;
    default:
      source = dec_varlong(&packet->value, source);
  }
  return source;
}

char * enc_play_toclient_scoreboard_score(char * dest, play_toclient_scoreboard_score source) {
  dest = enc_string(dest, source.item_name);
  dest = enc_byte(dest, source.action);
  dest = enc_string(dest, source.score_name);
  switch(source.action) {
    case 1:
      // void condition
      break;
    default:
      dest = enc_varlong(dest, source.value);
  }
  return dest;
}

void free_play_toclient_scoreboard_score(play_toclient_scoreboard_score packet) {
  free_string(packet.item_name);
  free_string(packet.score_name);
}

int walk_play_toclient_spawn_position(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_play_toclient_spawn_position(play_toclient_spawn_position packet) {
  return 8;
}

char * dec_play_toclient_spawn_position(play_toclient_spawn_position *packet, char * source) {
  source = dec_position(&packet->location, source);
  return source;
}

char * enc_play_toclient_spawn_position(char * dest, play_toclient_spawn_position source) {
  dest = enc_position(dest, source.location);
  return dest;
}

int walk_play_toclient_update_time(char * source, size_t max_len) {
  if(max_len < 16) return -1;
  return 16;
}

size_t size_play_toclient_update_time(play_toclient_update_time packet) {
  return 16;
}

char * dec_play_toclient_update_time(play_toclient_update_time *packet, char * source) {
  source = dec_be64(&packet->age, source);
  source = dec_be64(&packet->time, source);
  return source;
}

char * enc_play_toclient_update_time(char * dest, play_toclient_update_time source) {
  dest = enc_be64(dest, source.age);
  dest = enc_be64(dest, source.time);
  return dest;
}

int walk_play_toclient_title(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t action;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&action, source);
  switch(action) {
    case 2:
    case 1:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 3:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(action) {
    case 3:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(action) {
    case 3:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  return size;
}

size_t size_play_toclient_title(play_toclient_title packet) {
  size_t size = 0;
  size += size_varlong(packet.action);
  switch(packet.action) {
    case 2:
    case 1:
    case 0:
      size += size_string(packet.text);
      break;
  }
  switch(packet.action) {
    case 3:
      size += 4;
      break;
  }
  switch(packet.action) {
    case 3:
      size += 4;
      break;
  }
  switch(packet.action) {
    case 3:
      size += 4;
      break;
  }
  return size;
}

char * dec_play_toclient_title(play_toclient_title *packet, char * source) {
  source = dec_varlong(&packet->action, source);
  switch(packet->action) {
    case 2:
    case 1:
    case 0:
      if(!(source = dec_string(&packet->text, source))) return NULL;
      break;
  }
  switch(packet->action) {
    case 3:
      source = dec_be32(&packet->fade_in, source);
      break;
  }
  switch(packet->action) {
    case 3:
      source = dec_be32(&packet->stay, source);
      break;
  }
  switch(packet->action) {
    case 3:
      source = dec_be32(&packet->fade_out, source);
      break;
  }
  return source;
}

char * enc_play_toclient_title(char * dest, play_toclient_title source) {
  dest = enc_varlong(dest, source.action);
  switch(source.action) {
    case 2:
    case 1:
    case 0:
      dest = enc_string(dest, source.text);
      break;
  }
  switch(source.action) {
    case 3:
      dest = enc_be32(dest, source.fade_in);
      break;
  }
  switch(source.action) {
    case 3:
      dest = enc_be32(dest, source.stay);
      break;
  }
  switch(source.action) {
    case 3:
      dest = enc_be32(dest, source.fade_out);
      break;
  }
  return dest;
}

void free_play_toclient_title(play_toclient_title packet) {
  switch(packet.action) {
    case 2:
    case 1:
    case 0:
      free_string(packet.text);
      break;
  }
}

int walk_play_toclient_entity_sound_effect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 8) {
    return -1;
  }
  return size + 8;
}

size_t size_play_toclient_entity_sound_effect(play_toclient_entity_sound_effect packet) {
  size_t size = 0;
  size += size_varlong(packet.sound_id);
  size += size_varlong(packet.sound_category);
  size += size_varlong(packet.entity_id);
  return size + 8;
}

char * dec_play_toclient_entity_sound_effect(play_toclient_entity_sound_effect *packet, char * source) {
  source = dec_varlong(&packet->sound_id, source);
  source = dec_varlong(&packet->sound_category, source);
  source = dec_varlong(&packet->entity_id, source);
  source = dec_bef32(&packet->volume, source);
  source = dec_bef32(&packet->pitch, source);
  return source;
}

char * enc_play_toclient_entity_sound_effect(char * dest, play_toclient_entity_sound_effect source) {
  dest = enc_varlong(dest, source.sound_id);
  dest = enc_varlong(dest, source.sound_category);
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_bef32(dest, source.volume);
  dest = enc_bef32(dest, source.pitch);
  return dest;
}

int walk_play_toclient_stop_sound(char * source, size_t max_len) {
  int ret, size = 0;
  int8_t flags;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  max_len -= 1;
  source = dec_byte(&flags, source);
  switch(flags) {
    case 1:
    case 3:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(flags) {
    case 2:
    case 3:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  return size;
}

size_t size_play_toclient_stop_sound(play_toclient_stop_sound packet) {
  size_t size = 0;
  size += 1;
  switch(packet.flags) {
    case 1:
    case 3:
      size += size_varlong(packet.source);
      break;
  }
  switch(packet.flags) {
    case 2:
    case 3:
      size += size_string(packet.sound);
      break;
  }
  return size;
}

char * dec_play_toclient_stop_sound(play_toclient_stop_sound *packet, char * source) {
  source = dec_byte(&packet->flags, source);
  switch(packet->flags) {
    case 1:
    case 3:
      source = dec_varlong(&packet->source, source);
      break;
  }
  switch(packet->flags) {
    case 2:
    case 3:
      if(!(source = dec_string(&packet->sound, source))) return NULL;
      break;
  }
  return source;
}

char * enc_play_toclient_stop_sound(char * dest, play_toclient_stop_sound source) {
  dest = enc_byte(dest, source.flags);
  switch(source.flags) {
    case 1:
    case 3:
      dest = enc_varlong(dest, source.source);
      break;
  }
  switch(source.flags) {
    case 2:
    case 3:
      dest = enc_string(dest, source.sound);
      break;
  }
  return dest;
}

void free_play_toclient_stop_sound(play_toclient_stop_sound packet) {
  switch(packet.flags) {
    case 2:
    case 3:
      free_string(packet.sound);
      break;
  }
}

int walk_play_toclient_sound_effect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 20) {
    return -1;
  }
  return size + 20;
}

size_t size_play_toclient_sound_effect(play_toclient_sound_effect packet) {
  size_t size = 0;
  size += size_varlong(packet.sound_id);
  size += size_varlong(packet.sound_category);
  return size + 20;
}

char * dec_play_toclient_sound_effect(play_toclient_sound_effect *packet, char * source) {
  source = dec_varlong(&packet->sound_id, source);
  source = dec_varlong(&packet->sound_category, source);
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->y, source);
  source = dec_be32(&packet->z, source);
  source = dec_bef32(&packet->volume, source);
  source = dec_bef32(&packet->pitch, source);
  return source;
}

char * enc_play_toclient_sound_effect(char * dest, play_toclient_sound_effect source) {
  dest = enc_varlong(dest, source.sound_id);
  dest = enc_varlong(dest, source.sound_category);
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.y);
  dest = enc_be32(dest, source.z);
  dest = enc_bef32(dest, source.volume);
  dest = enc_bef32(dest, source.pitch);
  return dest;
}

int walk_play_toclient_playerlist_header(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_playerlist_header(play_toclient_playerlist_header packet) {
  size_t size = 0;
  size += size_string(packet.header);
  size += size_string(packet.footer);
  return size;
}

char * dec_play_toclient_playerlist_header(play_toclient_playerlist_header *packet, char * source) {
  if(!(source = dec_string(&packet->header, source))) return NULL;
  if(!(source = dec_string(&packet->footer, source))) return NULL;
  return source;
}

char * enc_play_toclient_playerlist_header(char * dest, play_toclient_playerlist_header source) {
  dest = enc_string(dest, source.header);
  dest = enc_string(dest, source.footer);
  return dest;
}

void free_play_toclient_playerlist_header(play_toclient_playerlist_header packet) {
  free_string(packet.header);
  free_string(packet.footer);
}

int walk_play_toclient_collect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_collect(play_toclient_collect packet) {
  size_t size = 0;
  size += size_varlong(packet.collected_entity_id);
  size += size_varlong(packet.collector_entity_id);
  size += size_varlong(packet.pickup_item_count);
  return size;
}

char * dec_play_toclient_collect(play_toclient_collect *packet, char * source) {
  source = dec_varlong(&packet->collected_entity_id, source);
  source = dec_varlong(&packet->collector_entity_id, source);
  source = dec_varlong(&packet->pickup_item_count, source);
  return source;
}

char * enc_play_toclient_collect(char * dest, play_toclient_collect source) {
  dest = enc_varlong(dest, source.collected_entity_id);
  dest = enc_varlong(dest, source.collector_entity_id);
  dest = enc_varlong(dest, source.pickup_item_count);
  return dest;
}

int walk_play_toclient_entity_teleport(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 27) {
    return -1;
  }
  return size + 27;
}

size_t size_play_toclient_entity_teleport(play_toclient_entity_teleport packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 27;
}

char * dec_play_toclient_entity_teleport(play_toclient_entity_teleport *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toclient_entity_teleport(char * dest, play_toclient_entity_teleport source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_byte(dest, source.yaw);
  dest = enc_byte(dest, source.pitch);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toclient_entity_head_rotation(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_entity_head_rotation(play_toclient_entity_head_rotation packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 1;
}

char * dec_play_toclient_entity_head_rotation(play_toclient_entity_head_rotation *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->head_yaw, source);
  return source;
}

char * enc_play_toclient_entity_head_rotation(char * dest, play_toclient_entity_head_rotation source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.head_yaw);
  return dest;
}

int walk_play_toclient_entity_effect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 2) {
    return -1;
  }
  size += 2;
  source += 2;
  max_len -= 2;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_entity_effect(play_toclient_entity_effect packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 2;
  size += size_varlong(packet.duration);
  return size + 1;
}

char * dec_play_toclient_entity_effect(play_toclient_entity_effect *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->effect_id, source);
  source = dec_byte(&packet->amplifier, source);
  source = dec_varlong(&packet->duration, source);
  source = dec_byte(&packet->hide_particles, source);
  return source;
}

char * enc_play_toclient_entity_effect(char * dest, play_toclient_entity_effect source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.effect_id);
  dest = enc_byte(dest, source.amplifier);
  dest = enc_varlong(dest, source.duration);
  dest = enc_byte(dest, source.hide_particles);
  return dest;
}

int walk_play_toclient_select_advancement_tab(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
      return -1;
  }
  uint8_t id_opt;
  source = dec_byte(&id_opt, source);
  size += 1;
  max_len -= 1;
  if(id_opt) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_select_advancement_tab(play_toclient_select_advancement_tab packet) {
  size_t size = 0;
  size += 1;
  if(packet.id.opt) {
    size += size_string(packet.id.val);
  }
  return size;
}

char * dec_play_toclient_select_advancement_tab(play_toclient_select_advancement_tab *packet, char * source) {
  source = dec_byte(&packet->id.opt, source);
  if(packet->id.opt) {
    if(!(source = dec_string(&packet->id.val, source))) return NULL;
  }
  return source;
}

char * enc_play_toclient_select_advancement_tab(char * dest, play_toclient_select_advancement_tab source) {
  dest = enc_byte(dest, source.id.opt);
  if(source.id.opt) {
    dest = enc_string(dest, source.id.val);
  }
  return dest;
}

void free_play_toclient_select_advancement_tab(play_toclient_select_advancement_tab packet) {
  if(packet.id.opt) {
    free_string(packet.id.val);
  }
}

int walk_play_toclient_declare_recipes(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t recipes_count;
  source = dec_varlong(&recipes_count, source);
  for(size_t i_0 = 0; i_0 < recipes_count; ++i_0) {
    sds type;
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    max_len -= ret;
    if(!(source = dec_string(&type, source))) {
      return -1;
    }
    if((ret = walk_string(source, max_len)) < 0) {
      free_string(type);
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if(!(sdscmp("minecraft:crafting_shapeless", type))) {
      if((ret = walk_string(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      if((ret = walk_varlong(source, max_len)) < 0) {
          free_string(type);
          return -1;
      }
      size += ret;
      max_len -= ret;
      int64_t ingredients_count;
      source = dec_varlong(&ingredients_count, source);
      for(size_t i_4 = 0; i_4 < ingredients_count; ++i_4) {
        if((ret = walk_ingredient(source, max_len)) < 0) {
          free_string(type);
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
      }
      if((ret = walk_slot(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    } else if(!(sdscmp("minecraft:crafting_shaped", type))) {
      int64_t width;
      if((ret = walk_varlong(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      max_len -= ret;
      source = dec_varlong(&width, source);
      int64_t height;
      if((ret = walk_varlong(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      max_len -= ret;
      source = dec_varlong(&height, source);
      if((ret = walk_string(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      for(size_t i_4 = 0; i_4 < width; ++i_4) {
        for(size_t i_5 = 0; i_5 < height; ++i_5) {
          if((ret = walk_ingredient(source, max_len)) < 0) {
            free_string(type);
            return -1;
          }
          size += ret;
          source += ret;
          max_len -= ret;
        }
      }
      if((ret = walk_slot(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    } else if(!(sdscmp("minecraft:smelting", type))) {
      if((ret = walk_smelting(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    } else if(!(sdscmp("minecraft:blasting", type))) {
      if((ret = walk_smelting(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    } else if(!(sdscmp("minecraft:smoking", type))) {
      if((ret = walk_smelting(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    } else if(!(sdscmp("minecraft:campfire_cooking", type))) {
      if((ret = walk_smelting(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    } else if(!(sdscmp("minecraft:stonecutting", type))) {
      if((ret = walk_string(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      if((ret = walk_ingredient(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      if((ret = walk_slot(source, max_len)) < 0) {
        free_string(type);
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
    }
    free_string(type);
  }
  return size;
}

size_t size_play_toclient_declare_recipes(play_toclient_declare_recipes packet) {
  size_t size = 0;
  size += size_varlong(packet.recipes.count);
  for(size_t i_0 = 0; i_0 < packet.recipes.count; ++i_0) {
    size += size_string(packet.recipes.base[i_0].type);
    size += size_string(packet.recipes.base[i_0].recipe_id);
    if(!(sdscmp("minecraft:crafting_shapeless", packet.recipes.base[i_0].type))) {
      size += size_string(packet.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.group);
      size += size_varlong(packet.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.count);
      for(size_t i_4 = 0; i_4 < packet.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.count; ++i_4) {
        size += size_ingredient(packet.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.base[i_4]);
      }
      size += size_slot(packet.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.result);
    } else if(!(sdscmp("minecraft:crafting_shaped", packet.recipes.base[i_0].type))) {
      size += size_varlong(packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.width);
      size += size_varlong(packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.height);
      size += size_string(packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.group);
      for(size_t i_4 = 0; i_4 < packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.width; ++i_4) {
        for(size_t i_5 = 0; i_5 < packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.height; ++i_5) {
          size += size_ingredient(packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.ingredients[i_4][i_5]);
        }
      }
      size += size_slot(packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.result);
    } else if(!(sdscmp("minecraft:smelting", packet.recipes.base[i_0].type))) {
      size += size_smelting(packet.recipes.base[i_0].data.enum_minecraft_smelting);
    } else if(!(sdscmp("minecraft:blasting", packet.recipes.base[i_0].type))) {
      size += size_smelting(packet.recipes.base[i_0].data.enum_minecraft_blasting);
    } else if(!(sdscmp("minecraft:smoking", packet.recipes.base[i_0].type))) {
      size += size_smelting(packet.recipes.base[i_0].data.enum_minecraft_smoking);
    } else if(!(sdscmp("minecraft:campfire_cooking", packet.recipes.base[i_0].type))) {
      size += size_smelting(packet.recipes.base[i_0].data.enum_minecraft_campfire_cooking);
    } else if(!(sdscmp("minecraft:stonecutting", packet.recipes.base[i_0].type))) {
      size += size_string(packet.recipes.base[i_0].data.enum_minecraft_stonecutting.group);
      size += size_ingredient(packet.recipes.base[i_0].data.enum_minecraft_stonecutting.ingredient);
      size += size_slot(packet.recipes.base[i_0].data.enum_minecraft_stonecutting.result);
    }
  }
  return size;
}

char * dec_play_toclient_declare_recipes(play_toclient_declare_recipes *packet, char * source) {
  source = dec_varlong(&packet->recipes.count, source);
  if(!(packet->recipes.base = malloc(sizeof(*packet->recipes.base) * packet->recipes.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->recipes.count; ++i_0) {
    if(!(source = dec_string(&packet->recipes.base[i_0].type, source))) return NULL;
    if(!(source = dec_string(&packet->recipes.base[i_0].recipe_id, source))) return NULL;
    if(!(sdscmp("minecraft:crafting_shapeless", packet->recipes.base[i_0].type))) {
      if(!(source = dec_string(&packet->recipes.base[i_0].data.enum_minecraft_crafting_shapeless.group, source))) return NULL;
      source = dec_varlong(&packet->recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.count, source);
      if(!(packet->recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.base = malloc(sizeof(*packet->recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.base) * packet->recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.count))) return NULL;
      for(size_t i_4 = 0; i_4 < packet->recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.count; ++i_4) {
        if(!(source = dec_ingredient(&packet->recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.base[i_4], source))) return NULL;
      }
      if(!(source = dec_slot(&packet->recipes.base[i_0].data.enum_minecraft_crafting_shapeless.result, source))) return NULL;
    } else if(!(sdscmp("minecraft:crafting_shaped", packet->recipes.base[i_0].type))) {
      source = dec_varlong(&packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.width, source);
      source = dec_varlong(&packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.height, source);
      if(!(source = dec_string(&packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.group, source))) return NULL;
      if(!(packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.ingredients = malloc(sizeof(*packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.ingredients) * packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.width))) return NULL;
      for(size_t i_4 = 0; i_4 < packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.width; ++i_4) {
        if(!(packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.ingredients[i_4] = malloc(sizeof(*packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.ingredients[i_4]) * packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.height))) return NULL;
        for(size_t i_5 = 0; i_5 < packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.height; ++i_5) {
          if(!(source = dec_ingredient(&packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.ingredients[i_4][i_5], source))) return NULL;
        }
      }
      if(!(source = dec_slot(&packet->recipes.base[i_0].data.enum_minecraft_crafting_shaped.result, source))) return NULL;
    } else if(!(sdscmp("minecraft:smelting", packet->recipes.base[i_0].type))) {
      if(!(source = dec_smelting(&packet->recipes.base[i_0].data.enum_minecraft_smelting, source))) return NULL;
    } else if(!(sdscmp("minecraft:blasting", packet->recipes.base[i_0].type))) {
      if(!(source = dec_smelting(&packet->recipes.base[i_0].data.enum_minecraft_blasting, source))) return NULL;
    } else if(!(sdscmp("minecraft:smoking", packet->recipes.base[i_0].type))) {
      if(!(source = dec_smelting(&packet->recipes.base[i_0].data.enum_minecraft_smoking, source))) return NULL;
    } else if(!(sdscmp("minecraft:campfire_cooking", packet->recipes.base[i_0].type))) {
      if(!(source = dec_smelting(&packet->recipes.base[i_0].data.enum_minecraft_campfire_cooking, source))) return NULL;
    } else if(!(sdscmp("minecraft:stonecutting", packet->recipes.base[i_0].type))) {
      if(!(source = dec_string(&packet->recipes.base[i_0].data.enum_minecraft_stonecutting.group, source))) return NULL;
      if(!(source = dec_ingredient(&packet->recipes.base[i_0].data.enum_minecraft_stonecutting.ingredient, source))) return NULL;
      if(!(source = dec_slot(&packet->recipes.base[i_0].data.enum_minecraft_stonecutting.result, source))) return NULL;
    }
  }
  return source;
}

char * enc_play_toclient_declare_recipes(char * dest, play_toclient_declare_recipes source) {
  dest = enc_varlong(dest, source.recipes.count);
  for(size_t i_0 = 0; i_0 < source.recipes.count; ++i_0) {
    dest = enc_string(dest, source.recipes.base[i_0].type);
    dest = enc_string(dest, source.recipes.base[i_0].recipe_id);
    if(!(sdscmp("minecraft:crafting_shapeless", source.recipes.base[i_0].type))) {
      dest = enc_string(dest, source.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.group);
      dest = enc_varlong(dest, source.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.count);
      for(size_t i_4 = 0; i_4 < source.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.count; ++i_4) {
        dest = enc_ingredient(dest, source.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.base[i_4]);
      }
      dest = enc_slot(dest, source.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.result);
    } else if(!(sdscmp("minecraft:crafting_shaped", source.recipes.base[i_0].type))) {
      dest = enc_varlong(dest, source.recipes.base[i_0].data.enum_minecraft_crafting_shaped.width);
      dest = enc_varlong(dest, source.recipes.base[i_0].data.enum_minecraft_crafting_shaped.height);
      dest = enc_string(dest, source.recipes.base[i_0].data.enum_minecraft_crafting_shaped.group);
      for(size_t i_4 = 0; i_4 < source.recipes.base[i_0].data.enum_minecraft_crafting_shaped.width; ++i_4) {
        for(size_t i_5 = 0; i_5 < source.recipes.base[i_0].data.enum_minecraft_crafting_shaped.height; ++i_5) {
          dest = enc_ingredient(dest, source.recipes.base[i_0].data.enum_minecraft_crafting_shaped.ingredients[i_4][i_5]);
        }
      }
      dest = enc_slot(dest, source.recipes.base[i_0].data.enum_minecraft_crafting_shaped.result);
    } else if(!(sdscmp("minecraft:smelting", source.recipes.base[i_0].type))) {
      dest = enc_smelting(dest, source.recipes.base[i_0].data.enum_minecraft_smelting);
    } else if(!(sdscmp("minecraft:blasting", source.recipes.base[i_0].type))) {
      dest = enc_smelting(dest, source.recipes.base[i_0].data.enum_minecraft_blasting);
    } else if(!(sdscmp("minecraft:smoking", source.recipes.base[i_0].type))) {
      dest = enc_smelting(dest, source.recipes.base[i_0].data.enum_minecraft_smoking);
    } else if(!(sdscmp("minecraft:campfire_cooking", source.recipes.base[i_0].type))) {
      dest = enc_smelting(dest, source.recipes.base[i_0].data.enum_minecraft_campfire_cooking);
    } else if(!(sdscmp("minecraft:stonecutting", source.recipes.base[i_0].type))) {
      dest = enc_string(dest, source.recipes.base[i_0].data.enum_minecraft_stonecutting.group);
      dest = enc_ingredient(dest, source.recipes.base[i_0].data.enum_minecraft_stonecutting.ingredient);
      dest = enc_slot(dest, source.recipes.base[i_0].data.enum_minecraft_stonecutting.result);
    }
  }
  return dest;
}

void free_play_toclient_declare_recipes(play_toclient_declare_recipes packet) {
  for(size_t i_0 = 0; i_0 < packet.recipes.count; ++i_0) {
    free_string(packet.recipes.base[i_0].type);
    free_string(packet.recipes.base[i_0].recipe_id);
    if(!(sdscmp("minecraft:crafting_shapeless", packet.recipes.base[i_0].type))) {
      free_string(packet.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.group);
      for(size_t i_4 = 0; i_4 < packet.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.count; ++i_4) {
        free_ingredient(packet.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.base[i_4]);
      }
      free(packet.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.ingredients.base);
      free_slot(packet.recipes.base[i_0].data.enum_minecraft_crafting_shapeless.result);
    } else if(!(sdscmp("minecraft:crafting_shaped", packet.recipes.base[i_0].type))) {
      free_string(packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.group);
      for(size_t i_4 = 0; i_4 < packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.width; ++i_4) {
        for(size_t i_5 = 0; i_5 < packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.height; ++i_5) {
          free_ingredient(packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.ingredients[i_4][i_5]);
        }
        free(packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.ingredients[i_4]);
      }
      free(packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.ingredients);
      free_slot(packet.recipes.base[i_0].data.enum_minecraft_crafting_shaped.result);
    } else if(!(sdscmp("minecraft:smelting", packet.recipes.base[i_0].type))) {
      free_smelting(packet.recipes.base[i_0].data.enum_minecraft_smelting);
    } else if(!(sdscmp("minecraft:blasting", packet.recipes.base[i_0].type))) {
      free_smelting(packet.recipes.base[i_0].data.enum_minecraft_blasting);
    } else if(!(sdscmp("minecraft:smoking", packet.recipes.base[i_0].type))) {
      free_smelting(packet.recipes.base[i_0].data.enum_minecraft_smoking);
    } else if(!(sdscmp("minecraft:campfire_cooking", packet.recipes.base[i_0].type))) {
      free_smelting(packet.recipes.base[i_0].data.enum_minecraft_campfire_cooking);
    } else if(!(sdscmp("minecraft:stonecutting", packet.recipes.base[i_0].type))) {
      free_string(packet.recipes.base[i_0].data.enum_minecraft_stonecutting.group);
      free_ingredient(packet.recipes.base[i_0].data.enum_minecraft_stonecutting.ingredient);
      free_slot(packet.recipes.base[i_0].data.enum_minecraft_stonecutting.result);
    }
  }
  free(packet.recipes.base);
}

int walk_play_toclient_tags(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_itemtag_array(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_itemtag_array(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_itemtag_array(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_itemtag_array(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_tags(play_toclient_tags packet) {
  size_t size = 0;
  size += size_itemtag_array(packet.block_tags);
  size += size_itemtag_array(packet.item_tags);
  size += size_itemtag_array(packet.fluid_tags);
  size += size_itemtag_array(packet.entity_tags);
  return size;
}

char * dec_play_toclient_tags(play_toclient_tags *packet, char * source) {
  if(!(source = dec_itemtag_array(&packet->block_tags, source))) return NULL;
  if(!(source = dec_itemtag_array(&packet->item_tags, source))) return NULL;
  if(!(source = dec_itemtag_array(&packet->fluid_tags, source))) return NULL;
  if(!(source = dec_itemtag_array(&packet->entity_tags, source))) return NULL;
  return source;
}

char * enc_play_toclient_tags(char * dest, play_toclient_tags source) {
  dest = enc_itemtag_array(dest, source.block_tags);
  dest = enc_itemtag_array(dest, source.item_tags);
  dest = enc_itemtag_array(dest, source.fluid_tags);
  dest = enc_itemtag_array(dest, source.entity_tags);
  return dest;
}

void free_play_toclient_tags(play_toclient_tags packet) {
  free_itemtag_array(packet.block_tags);
  free_itemtag_array(packet.item_tags);
  free_itemtag_array(packet.fluid_tags);
  free_itemtag_array(packet.entity_tags);
}

int walk_play_toclient_acknowledge_player_digging(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_acknowledge_player_digging(play_toclient_acknowledge_player_digging packet) {
  size_t size = 0;
  size += 8;
  size += size_varlong(packet.block);
  size += size_varlong(packet.status);
  return size + 1;
}

char * dec_play_toclient_acknowledge_player_digging(play_toclient_acknowledge_player_digging *packet, char * source) {
  source = dec_position(&packet->location, source);
  source = dec_varlong(&packet->block, source);
  source = dec_varlong(&packet->status, source);
  source = dec_byte(&packet->successful, source);
  return source;
}

char * enc_play_toclient_acknowledge_player_digging(char * dest, play_toclient_acknowledge_player_digging source) {
  dest = enc_position(dest, source.location);
  dest = enc_varlong(dest, source.block);
  dest = enc_varlong(dest, source.status);
  dest = enc_byte(dest, source.successful);
  return dest;
}

int walk_play_toserver_teleport_confirm(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_teleport_confirm(play_toserver_teleport_confirm packet) {
  size_t size = 0;
  size += size_varlong(packet.teleport_id);
  return size;
}

char * dec_play_toserver_teleport_confirm(play_toserver_teleport_confirm *packet, char * source) {
  source = dec_varlong(&packet->teleport_id, source);
  return source;
}

char * enc_play_toserver_teleport_confirm(char * dest, play_toserver_teleport_confirm source) {
  dest = enc_varlong(dest, source.teleport_id);
  return dest;
}

int walk_play_toserver_query_block_nbt(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 8) {
    return -1;
  }
  return size + 8;
}

size_t size_play_toserver_query_block_nbt(play_toserver_query_block_nbt packet) {
  size_t size = 0;
  size += size_varlong(packet.transaction_id);
  return size + 8;
}

char * dec_play_toserver_query_block_nbt(play_toserver_query_block_nbt *packet, char * source) {
  source = dec_varlong(&packet->transaction_id, source);
  source = dec_position(&packet->location, source);
  return source;
}

char * enc_play_toserver_query_block_nbt(char * dest, play_toserver_query_block_nbt source) {
  dest = enc_varlong(dest, source.transaction_id);
  dest = enc_position(dest, source.location);
  return dest;
}

int walk_play_toserver_set_difficulty(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toserver_set_difficulty(play_toserver_set_difficulty packet) {
  return 1;
}

char * dec_play_toserver_set_difficulty(play_toserver_set_difficulty *packet, char * source) {
  source = dec_byte(&packet->new_difficulty, source);
  return source;
}

char * enc_play_toserver_set_difficulty(char * dest, play_toserver_set_difficulty source) {
  dest = enc_byte(dest, source.new_difficulty);
  return dest;
}

int walk_play_toserver_edit_book(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_slot(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_edit_book(play_toserver_edit_book packet) {
  size_t size = 0;
  size += size_slot(packet.new_book);
  size += 1;
  size += size_varlong(packet.hand);
  return size;
}

char * dec_play_toserver_edit_book(play_toserver_edit_book *packet, char * source) {
  if(!(source = dec_slot(&packet->new_book, source))) return NULL;
  source = dec_byte(&packet->signing, source);
  source = dec_varlong(&packet->hand, source);
  return source;
}

char * enc_play_toserver_edit_book(char * dest, play_toserver_edit_book source) {
  dest = enc_slot(dest, source.new_book);
  dest = enc_byte(dest, source.signing);
  dest = enc_varlong(dest, source.hand);
  return dest;
}

void free_play_toserver_edit_book(play_toserver_edit_book packet) {
  free_slot(packet.new_book);
}

int walk_play_toserver_query_entity_nbt(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_query_entity_nbt(play_toserver_query_entity_nbt packet) {
  size_t size = 0;
  size += size_varlong(packet.transaction_id);
  size += size_varlong(packet.entity_id);
  return size;
}

char * dec_play_toserver_query_entity_nbt(play_toserver_query_entity_nbt *packet, char * source) {
  source = dec_varlong(&packet->transaction_id, source);
  source = dec_varlong(&packet->entity_id, source);
  return source;
}

char * enc_play_toserver_query_entity_nbt(char * dest, play_toserver_query_entity_nbt source) {
  dest = enc_varlong(dest, source.transaction_id);
  dest = enc_varlong(dest, source.entity_id);
  return dest;
}

int walk_play_toserver_pick_item(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_pick_item(play_toserver_pick_item packet) {
  size_t size = 0;
  size += size_varlong(packet.slot);
  return size;
}

char * dec_play_toserver_pick_item(play_toserver_pick_item *packet, char * source) {
  source = dec_varlong(&packet->slot, source);
  return source;
}

char * enc_play_toserver_pick_item(char * dest, play_toserver_pick_item source) {
  dest = enc_varlong(dest, source.slot);
  return dest;
}

int walk_play_toserver_name_item(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_name_item(play_toserver_name_item packet) {
  size_t size = 0;
  size += size_string(packet.name);
  return size;
}

char * dec_play_toserver_name_item(play_toserver_name_item *packet, char * source) {
  if(!(source = dec_string(&packet->name, source))) return NULL;
  return source;
}

char * enc_play_toserver_name_item(char * dest, play_toserver_name_item source) {
  dest = enc_string(dest, source.name);
  return dest;
}

void free_play_toserver_name_item(play_toserver_name_item packet) {
  free_string(packet.name);
}

int walk_play_toserver_select_trade(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_select_trade(play_toserver_select_trade packet) {
  size_t size = 0;
  size += size_varlong(packet.slot);
  return size;
}

char * dec_play_toserver_select_trade(play_toserver_select_trade *packet, char * source) {
  source = dec_varlong(&packet->slot, source);
  return source;
}

char * enc_play_toserver_select_trade(char * dest, play_toserver_select_trade source) {
  dest = enc_varlong(dest, source.slot);
  return dest;
}

int walk_play_toserver_set_beacon_effect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_set_beacon_effect(play_toserver_set_beacon_effect packet) {
  size_t size = 0;
  size += size_varlong(packet.primary_effect);
  size += size_varlong(packet.secondary_effect);
  return size;
}

char * dec_play_toserver_set_beacon_effect(play_toserver_set_beacon_effect *packet, char * source) {
  source = dec_varlong(&packet->primary_effect, source);
  source = dec_varlong(&packet->secondary_effect, source);
  return source;
}

char * enc_play_toserver_set_beacon_effect(char * dest, play_toserver_set_beacon_effect source) {
  dest = enc_varlong(dest, source.primary_effect);
  dest = enc_varlong(dest, source.secondary_effect);
  return dest;
}

int walk_play_toserver_update_command_block(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toserver_update_command_block(play_toserver_update_command_block packet) {
  size_t size = 0;
  size += 8;
  size += size_string(packet.command);
  size += size_varlong(packet.mode);
  return size + 1;
}

char * dec_play_toserver_update_command_block(play_toserver_update_command_block *packet, char * source) {
  source = dec_position(&packet->location, source);
  if(!(source = dec_string(&packet->command, source))) return NULL;
  source = dec_varlong(&packet->mode, source);
  source = dec_byte(&packet->flags, source);
  return source;
}

char * enc_play_toserver_update_command_block(char * dest, play_toserver_update_command_block source) {
  dest = enc_position(dest, source.location);
  dest = enc_string(dest, source.command);
  dest = enc_varlong(dest, source.mode);
  dest = enc_byte(dest, source.flags);
  return dest;
}

void free_play_toserver_update_command_block(play_toserver_update_command_block packet) {
  free_string(packet.command);
}

int walk_play_toserver_update_command_block_minecart(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toserver_update_command_block_minecart(play_toserver_update_command_block_minecart packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += size_string(packet.command);
  return size + 1;
}

char * dec_play_toserver_update_command_block_minecart(play_toserver_update_command_block_minecart *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  if(!(source = dec_string(&packet->command, source))) return NULL;
  source = dec_byte(&packet->track_output, source);
  return source;
}

char * enc_play_toserver_update_command_block_minecart(char * dest, play_toserver_update_command_block_minecart source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_string(dest, source.command);
  dest = enc_byte(dest, source.track_output);
  return dest;
}

void free_play_toserver_update_command_block_minecart(play_toserver_update_command_block_minecart packet) {
  free_string(packet.command);
}

int walk_play_toserver_update_structure_block(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 6) {
    return -1;
  }
  size += 6;
  source += 6;
  max_len -= 6;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  source += 4;
  max_len -= 4;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toserver_update_structure_block(play_toserver_update_structure_block packet) {
  size_t size = 0;
  size += 8;
  size += size_varlong(packet.action);
  size += size_varlong(packet.mode);
  size += size_string(packet.name);
  size += 6;
  size += size_varlong(packet.mirror);
  size += size_varlong(packet.rotation);
  size += size_string(packet.metadata);
  size += 4;
  size += size_varlong(packet.seed);
  return size + 1;
}

char * dec_play_toserver_update_structure_block(play_toserver_update_structure_block *packet, char * source) {
  source = dec_position(&packet->location, source);
  source = dec_varlong(&packet->action, source);
  source = dec_varlong(&packet->mode, source);
  if(!(source = dec_string(&packet->name, source))) return NULL;
  source = dec_byte(&packet->offset_x, source);
  source = dec_byte(&packet->offset_y, source);
  source = dec_byte(&packet->offset_z, source);
  source = dec_byte(&packet->size_x, source);
  source = dec_byte(&packet->size_y, source);
  source = dec_byte(&packet->size_z, source);
  source = dec_varlong(&packet->mirror, source);
  source = dec_varlong(&packet->rotation, source);
  if(!(source = dec_string(&packet->metadata, source))) return NULL;
  source = dec_bef32(&packet->integrity, source);
  source = dec_varlong(&packet->seed, source);
  source = dec_byte(&packet->flags, source);
  return source;
}

char * enc_play_toserver_update_structure_block(char * dest, play_toserver_update_structure_block source) {
  dest = enc_position(dest, source.location);
  dest = enc_varlong(dest, source.action);
  dest = enc_varlong(dest, source.mode);
  dest = enc_string(dest, source.name);
  dest = enc_byte(dest, source.offset_x);
  dest = enc_byte(dest, source.offset_y);
  dest = enc_byte(dest, source.offset_z);
  dest = enc_byte(dest, source.size_x);
  dest = enc_byte(dest, source.size_y);
  dest = enc_byte(dest, source.size_z);
  dest = enc_varlong(dest, source.mirror);
  dest = enc_varlong(dest, source.rotation);
  dest = enc_string(dest, source.metadata);
  dest = enc_bef32(dest, source.integrity);
  dest = enc_varlong(dest, source.seed);
  dest = enc_byte(dest, source.flags);
  return dest;
}

void free_play_toserver_update_structure_block(play_toserver_update_structure_block packet) {
  free_string(packet.name);
  free_string(packet.metadata);
}

int walk_play_toserver_tab_complete(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_tab_complete(play_toserver_tab_complete packet) {
  size_t size = 0;
  size += size_varlong(packet.transaction_id);
  size += size_string(packet.text);
  return size;
}

char * dec_play_toserver_tab_complete(play_toserver_tab_complete *packet, char * source) {
  source = dec_varlong(&packet->transaction_id, source);
  if(!(source = dec_string(&packet->text, source))) return NULL;
  return source;
}

char * enc_play_toserver_tab_complete(char * dest, play_toserver_tab_complete source) {
  dest = enc_varlong(dest, source.transaction_id);
  dest = enc_string(dest, source.text);
  return dest;
}

void free_play_toserver_tab_complete(play_toserver_tab_complete packet) {
  free_string(packet.text);
}

int walk_play_toserver_chat(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_chat(play_toserver_chat packet) {
  size_t size = 0;
  size += size_string(packet.message);
  return size;
}

char * dec_play_toserver_chat(play_toserver_chat *packet, char * source) {
  if(!(source = dec_string(&packet->message, source))) return NULL;
  return source;
}

char * enc_play_toserver_chat(char * dest, play_toserver_chat source) {
  dest = enc_string(dest, source.message);
  return dest;
}

void free_play_toserver_chat(play_toserver_chat packet) {
  free_string(packet.message);
}

int walk_play_toserver_client_command(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_client_command(play_toserver_client_command packet) {
  size_t size = 0;
  size += size_varlong(packet.action_id);
  return size;
}

char * dec_play_toserver_client_command(play_toserver_client_command *packet, char * source) {
  source = dec_varlong(&packet->action_id, source);
  return source;
}

char * enc_play_toserver_client_command(char * dest, play_toserver_client_command source) {
  dest = enc_varlong(dest, source.action_id);
  return dest;
}

int walk_play_toserver_settings(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 2) {
    return -1;
  }
  size += 2;
  source += 2;
  max_len -= 2;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_settings(play_toserver_settings packet) {
  size_t size = 0;
  size += size_string(packet.locale);
  size += 1;
  size += size_varlong(packet.chat_flags);
  size += 2;
  size += size_varlong(packet.main_hand);
  return size;
}

char * dec_play_toserver_settings(play_toserver_settings *packet, char * source) {
  if(!(source = dec_string(&packet->locale, source))) return NULL;
  source = dec_byte(&packet->view_distance, source);
  source = dec_varlong(&packet->chat_flags, source);
  source = dec_byte(&packet->chat_colors, source);
  source = dec_byte(&packet->skin_parts, source);
  source = dec_varlong(&packet->main_hand, source);
  return source;
}

char * enc_play_toserver_settings(char * dest, play_toserver_settings source) {
  dest = enc_string(dest, source.locale);
  dest = enc_byte(dest, source.view_distance);
  dest = enc_varlong(dest, source.chat_flags);
  dest = enc_byte(dest, source.chat_colors);
  dest = enc_byte(dest, source.skin_parts);
  dest = enc_varlong(dest, source.main_hand);
  return dest;
}

void free_play_toserver_settings(play_toserver_settings packet) {
  free_string(packet.locale);
}

int walk_play_toserver_transaction(char * source, size_t max_len) {
  if(max_len < 4) return -1;
  return 4;
}

size_t size_play_toserver_transaction(play_toserver_transaction packet) {
  return 4;
}

char * dec_play_toserver_transaction(play_toserver_transaction *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->action, source);
  source = dec_byte(&packet->accepted, source);
  return source;
}

char * enc_play_toserver_transaction(char * dest, play_toserver_transaction source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.action);
  dest = enc_byte(dest, source.accepted);
  return dest;
}

int walk_play_toserver_enchant_item(char * source, size_t max_len) {
  if(max_len < 2) return -1;
  return 2;
}

size_t size_play_toserver_enchant_item(play_toserver_enchant_item packet) {
  return 2;
}

char * dec_play_toserver_enchant_item(play_toserver_enchant_item *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_byte(&packet->enchantment, source);
  return source;
}

char * enc_play_toserver_enchant_item(char * dest, play_toserver_enchant_item source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_byte(dest, source.enchantment);
  return dest;
}

int walk_play_toserver_window_click(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 7) {
    return -1;
  }
  size += 7;
  source += 7;
  max_len -= 7;
  if((ret = walk_slot(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_window_click(play_toserver_window_click packet) {
  size_t size = 0;
  size += 7;
  size += size_slot(packet.item);
  return size;
}

char * dec_play_toserver_window_click(play_toserver_window_click *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->slot, source);
  source = dec_byte(&packet->mouse_button, source);
  source = dec_be16(&packet->action, source);
  source = dec_byte(&packet->mode, source);
  if(!(source = dec_slot(&packet->item, source))) return NULL;
  return source;
}

char * enc_play_toserver_window_click(char * dest, play_toserver_window_click source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.slot);
  dest = enc_byte(dest, source.mouse_button);
  dest = enc_be16(dest, source.action);
  dest = enc_byte(dest, source.mode);
  dest = enc_slot(dest, source.item);
  return dest;
}

void free_play_toserver_window_click(play_toserver_window_click packet) {
  free_slot(packet.item);
}

int walk_play_toserver_close_window(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toserver_close_window(play_toserver_close_window packet) {
  return 1;
}

char * dec_play_toserver_close_window(play_toserver_close_window *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  return source;
}

char * enc_play_toserver_close_window(char * dest, play_toserver_close_window source) {
  dest = enc_byte(dest, source.window_id);
  return dest;
}

int walk_play_toserver_custom_payload(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  ret = max_len;
  return size + ret;
}

size_t size_play_toserver_custom_payload(play_toserver_custom_payload packet) {
  size_t size = 0;
  size += size_string(packet.channel);
  size += packet.data.len;
  return size;
}

char * dec_play_toserver_custom_payload(play_toserver_custom_payload *packet, char * source, size_t total_size) {
  char * endptr = source + total_size;
  if(!(source = dec_string(&packet->channel, source))) return NULL;
  source = dec_buffer(&packet->data, source, endptr - source);
  return source;
}

char * enc_play_toserver_custom_payload(char * dest, play_toserver_custom_payload source) {
  dest = enc_string(dest, source.channel);
  dest = enc_buffer(dest, source.data);
  return dest;
}

void free_play_toserver_custom_payload(play_toserver_custom_payload packet) {
  free_string(packet.channel);
  free(packet.data.base);
}

int walk_play_toserver_use_entity(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  int64_t mouse;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&mouse, source);
  switch(mouse) {
    case 2:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(mouse) {
    case 2:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(mouse) {
    case 2:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(mouse) {
    case 2:
    case 0:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  return size;
}

size_t size_play_toserver_use_entity(play_toserver_use_entity packet) {
  size_t size = 0;
  size += size_varlong(packet.target);
  size += size_varlong(packet.mouse);
  switch(packet.mouse) {
    case 2:
      size += 4;
      break;
  }
  switch(packet.mouse) {
    case 2:
      size += 4;
      break;
  }
  switch(packet.mouse) {
    case 2:
      size += 4;
      break;
  }
  switch(packet.mouse) {
    case 2:
    case 0:
      size += size_varlong(packet.hand);
      break;
  }
  return size;
}

char * dec_play_toserver_use_entity(play_toserver_use_entity *packet, char * source) {
  source = dec_varlong(&packet->target, source);
  source = dec_varlong(&packet->mouse, source);
  switch(packet->mouse) {
    case 2:
      source = dec_bef32(&packet->x, source);
      break;
  }
  switch(packet->mouse) {
    case 2:
      source = dec_bef32(&packet->y, source);
      break;
  }
  switch(packet->mouse) {
    case 2:
      source = dec_bef32(&packet->z, source);
      break;
  }
  switch(packet->mouse) {
    case 2:
    case 0:
      source = dec_varlong(&packet->hand, source);
      break;
  }
  return source;
}

char * enc_play_toserver_use_entity(char * dest, play_toserver_use_entity source) {
  dest = enc_varlong(dest, source.target);
  dest = enc_varlong(dest, source.mouse);
  switch(source.mouse) {
    case 2:
      dest = enc_bef32(dest, source.x);
      break;
  }
  switch(source.mouse) {
    case 2:
      dest = enc_bef32(dest, source.y);
      break;
  }
  switch(source.mouse) {
    case 2:
      dest = enc_bef32(dest, source.z);
      break;
  }
  switch(source.mouse) {
    case 2:
    case 0:
      dest = enc_varlong(dest, source.hand);
      break;
  }
  return dest;
}

int walk_play_toserver_keep_alive(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_play_toserver_keep_alive(play_toserver_keep_alive packet) {
  return 8;
}

char * dec_play_toserver_keep_alive(play_toserver_keep_alive *packet, char * source) {
  source = dec_be64(&packet->keep_alive_id, source);
  return source;
}

char * enc_play_toserver_keep_alive(char * dest, play_toserver_keep_alive source) {
  dest = enc_be64(dest, source.keep_alive_id);
  return dest;
}

int walk_play_toserver_lock_difficulty(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toserver_lock_difficulty(play_toserver_lock_difficulty packet) {
  return 1;
}

char * dec_play_toserver_lock_difficulty(play_toserver_lock_difficulty *packet, char * source) {
  source = dec_byte(&packet->locked, source);
  return source;
}

char * enc_play_toserver_lock_difficulty(char * dest, play_toserver_lock_difficulty source) {
  dest = enc_byte(dest, source.locked);
  return dest;
}

int walk_play_toserver_position(char * source, size_t max_len) {
  if(max_len < 25) return -1;
  return 25;
}

size_t size_play_toserver_position(play_toserver_position packet) {
  return 25;
}

char * dec_play_toserver_position(play_toserver_position *packet, char * source) {
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toserver_position(char * dest, play_toserver_position source) {
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toserver_position_look(char * source, size_t max_len) {
  if(max_len < 33) return -1;
  return 33;
}

size_t size_play_toserver_position_look(play_toserver_position_look packet) {
  return 33;
}

char * dec_play_toserver_position_look(play_toserver_position_look *packet, char * source) {
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_bef32(&packet->yaw, source);
  source = dec_bef32(&packet->pitch, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toserver_position_look(char * dest, play_toserver_position_look source) {
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_bef32(dest, source.yaw);
  dest = enc_bef32(dest, source.pitch);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toserver_look(char * source, size_t max_len) {
  if(max_len < 9) return -1;
  return 9;
}

size_t size_play_toserver_look(play_toserver_look packet) {
  return 9;
}

char * dec_play_toserver_look(play_toserver_look *packet, char * source) {
  source = dec_bef32(&packet->yaw, source);
  source = dec_bef32(&packet->pitch, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toserver_look(char * dest, play_toserver_look source) {
  dest = enc_bef32(dest, source.yaw);
  dest = enc_bef32(dest, source.pitch);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toserver_flying(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toserver_flying(play_toserver_flying packet) {
  return 1;
}

char * dec_play_toserver_flying(play_toserver_flying *packet, char * source) {
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toserver_flying(char * dest, play_toserver_flying source) {
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toserver_vehicle_move(char * source, size_t max_len) {
  if(max_len < 32) return -1;
  return 32;
}

size_t size_play_toserver_vehicle_move(play_toserver_vehicle_move packet) {
  return 32;
}

char * dec_play_toserver_vehicle_move(play_toserver_vehicle_move *packet, char * source) {
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_bef32(&packet->yaw, source);
  source = dec_bef32(&packet->pitch, source);
  return source;
}

char * enc_play_toserver_vehicle_move(char * dest, play_toserver_vehicle_move source) {
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_bef32(dest, source.yaw);
  dest = enc_bef32(dest, source.pitch);
  return dest;
}

int walk_play_toserver_steer_boat(char * source, size_t max_len) {
  if(max_len < 2) return -1;
  return 2;
}

size_t size_play_toserver_steer_boat(play_toserver_steer_boat packet) {
  return 2;
}

char * dec_play_toserver_steer_boat(play_toserver_steer_boat *packet, char * source) {
  source = dec_byte(&packet->unknown1, source);
  source = dec_byte(&packet->unknown2, source);
  return source;
}

char * enc_play_toserver_steer_boat(char * dest, play_toserver_steer_boat source) {
  dest = enc_byte(dest, source.unknown1);
  dest = enc_byte(dest, source.unknown2);
  return dest;
}

int walk_play_toserver_craft_recipe_request(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toserver_craft_recipe_request(play_toserver_craft_recipe_request packet) {
  size_t size = 0;
  size += 1;
  size += size_string(packet.recipe);
  return size + 1;
}

char * dec_play_toserver_craft_recipe_request(play_toserver_craft_recipe_request *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  if(!(source = dec_string(&packet->recipe, source))) return NULL;
  source = dec_byte(&packet->make_all, source);
  return source;
}

char * enc_play_toserver_craft_recipe_request(char * dest, play_toserver_craft_recipe_request source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_string(dest, source.recipe);
  dest = enc_byte(dest, source.make_all);
  return dest;
}

void free_play_toserver_craft_recipe_request(play_toserver_craft_recipe_request packet) {
  free_string(packet.recipe);
}

int walk_play_toserver_abilities(char * source, size_t max_len) {
  if(max_len < 9) return -1;
  return 9;
}

size_t size_play_toserver_abilities(play_toserver_abilities packet) {
  return 9;
}

char * dec_play_toserver_abilities(play_toserver_abilities *packet, char * source) {
  source = dec_byte(&packet->flags, source);
  source = dec_bef32(&packet->flying_speed, source);
  source = dec_bef32(&packet->walking_speed, source);
  return source;
}

char * enc_play_toserver_abilities(char * dest, play_toserver_abilities source) {
  dest = enc_byte(dest, source.flags);
  dest = enc_bef32(dest, source.flying_speed);
  dest = enc_bef32(dest, source.walking_speed);
  return dest;
}

int walk_play_toserver_block_dig(char * source, size_t max_len) {
  if(max_len < 10) return -1;
  return 10;
}

size_t size_play_toserver_block_dig(play_toserver_block_dig packet) {
  return 10;
}

char * dec_play_toserver_block_dig(play_toserver_block_dig *packet, char * source) {
  source = dec_byte(&packet->status, source);
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->face, source);
  return source;
}

char * enc_play_toserver_block_dig(char * dest, play_toserver_block_dig source) {
  dest = enc_byte(dest, source.status);
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.face);
  return dest;
}

int walk_play_toserver_entity_action(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_entity_action(play_toserver_entity_action packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += size_varlong(packet.action_id);
  size += size_varlong(packet.jump_boost);
  return size;
}

char * dec_play_toserver_entity_action(play_toserver_entity_action *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_varlong(&packet->action_id, source);
  source = dec_varlong(&packet->jump_boost, source);
  return source;
}

char * enc_play_toserver_entity_action(char * dest, play_toserver_entity_action source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_varlong(dest, source.action_id);
  dest = enc_varlong(dest, source.jump_boost);
  return dest;
}

int walk_play_toserver_steer_vehicle(char * source, size_t max_len) {
  if(max_len < 9) return -1;
  return 9;
}

size_t size_play_toserver_steer_vehicle(play_toserver_steer_vehicle packet) {
  return 9;
}

char * dec_play_toserver_steer_vehicle(play_toserver_steer_vehicle *packet, char * source) {
  source = dec_bef32(&packet->sideways, source);
  source = dec_bef32(&packet->forward, source);
  source = dec_byte(&packet->jump, source);
  return source;
}

char * enc_play_toserver_steer_vehicle(char * dest, play_toserver_steer_vehicle source) {
  dest = enc_bef32(dest, source.sideways);
  dest = enc_bef32(dest, source.forward);
  dest = enc_byte(dest, source.jump);
  return dest;
}

int walk_play_toserver_crafting_book_data(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t type;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&type, source);
  switch(type) {
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
    case 1:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  return size;
}

size_t size_play_toserver_crafting_book_data(play_toserver_crafting_book_data packet) {
  size_t size = 0;
  size += size_varlong(packet.type);
  switch(packet.type) {
    case 0:
      size += size_string(packet.anonymous.enum_0.displayed_recipe);
      break;
    case 1:
      size += 8;
      break;
  }
  return size;
}

char * dec_play_toserver_crafting_book_data(play_toserver_crafting_book_data *packet, char * source) {
  source = dec_varlong(&packet->type, source);
  switch(packet->type) {
    case 0:
      if(!(source = dec_string(&packet->anonymous.enum_0.displayed_recipe, source))) return NULL;
      break;
    case 1:
      source = dec_byte(&packet->anonymous.enum_1.crafting_book_open, source);
      source = dec_byte(&packet->anonymous.enum_1.crafting_filter, source);
      source = dec_byte(&packet->anonymous.enum_1.smelting_book_open, source);
      source = dec_byte(&packet->anonymous.enum_1.smelting_filter, source);
      source = dec_byte(&packet->anonymous.enum_1.blasting_book_open, source);
      source = dec_byte(&packet->anonymous.enum_1.blasting_filter, source);
      source = dec_byte(&packet->anonymous.enum_1.smoking_book_open, source);
      source = dec_byte(&packet->anonymous.enum_1.smoking_filter, source);
      break;
  }
  return source;
}

char * enc_play_toserver_crafting_book_data(char * dest, play_toserver_crafting_book_data source) {
  dest = enc_varlong(dest, source.type);
  switch(source.type) {
    case 0:
      dest = enc_string(dest, source.anonymous.enum_0.displayed_recipe);
      break;
    case 1:
      dest = enc_byte(dest, source.anonymous.enum_1.crafting_book_open);
      dest = enc_byte(dest, source.anonymous.enum_1.crafting_filter);
      dest = enc_byte(dest, source.anonymous.enum_1.smelting_book_open);
      dest = enc_byte(dest, source.anonymous.enum_1.smelting_filter);
      dest = enc_byte(dest, source.anonymous.enum_1.blasting_book_open);
      dest = enc_byte(dest, source.anonymous.enum_1.blasting_filter);
      dest = enc_byte(dest, source.anonymous.enum_1.smoking_book_open);
      dest = enc_byte(dest, source.anonymous.enum_1.smoking_filter);
      break;
  }
  return dest;
}

void free_play_toserver_crafting_book_data(play_toserver_crafting_book_data packet) {
  switch(packet.type) {
    case 0:
      free_string(packet.anonymous.enum_0.displayed_recipe);
      break;
    case 1:
      // No free-able types
      break;
  }
}

int walk_play_toserver_resource_pack_receive(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_resource_pack_receive(play_toserver_resource_pack_receive packet) {
  size_t size = 0;
  size += size_varlong(packet.result);
  return size;
}

char * dec_play_toserver_resource_pack_receive(play_toserver_resource_pack_receive *packet, char * source) {
  source = dec_varlong(&packet->result, source);
  return source;
}

char * enc_play_toserver_resource_pack_receive(char * dest, play_toserver_resource_pack_receive source) {
  dest = enc_varlong(dest, source.result);
  return dest;
}

int walk_play_toserver_held_item_slot(char * source, size_t max_len) {
  if(max_len < 2) return -1;
  return 2;
}

size_t size_play_toserver_held_item_slot(play_toserver_held_item_slot packet) {
  return 2;
}

char * dec_play_toserver_held_item_slot(play_toserver_held_item_slot *packet, char * source) {
  source = dec_be16(&packet->slot_id, source);
  return source;
}

char * enc_play_toserver_held_item_slot(char * dest, play_toserver_held_item_slot source) {
  dest = enc_be16(dest, source.slot_id);
  return dest;
}

int walk_play_toserver_set_creative_slot(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 2) {
    return -1;
  }
  size += 2;
  source += 2;
  max_len -= 2;
  if((ret = walk_slot(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_set_creative_slot(play_toserver_set_creative_slot packet) {
  size_t size = 0;
  size += 2;
  size += size_slot(packet.item);
  return size;
}

char * dec_play_toserver_set_creative_slot(play_toserver_set_creative_slot *packet, char * source) {
  source = dec_be16(&packet->slot, source);
  if(!(source = dec_slot(&packet->item, source))) return NULL;
  return source;
}

char * enc_play_toserver_set_creative_slot(char * dest, play_toserver_set_creative_slot source) {
  dest = enc_be16(dest, source.slot);
  dest = enc_slot(dest, source.item);
  return dest;
}

void free_play_toserver_set_creative_slot(play_toserver_set_creative_slot packet) {
  free_slot(packet.item);
}

int walk_play_toserver_update_jigsaw_block(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_update_jigsaw_block(play_toserver_update_jigsaw_block packet) {
  size_t size = 0;
  size += 8;
  size += size_string(packet.attachment_type);
  size += size_string(packet.target_pool);
  size += size_string(packet.final_state);
  return size;
}

char * dec_play_toserver_update_jigsaw_block(play_toserver_update_jigsaw_block *packet, char * source) {
  source = dec_position(&packet->location, source);
  if(!(source = dec_string(&packet->attachment_type, source))) return NULL;
  if(!(source = dec_string(&packet->target_pool, source))) return NULL;
  if(!(source = dec_string(&packet->final_state, source))) return NULL;
  return source;
}

char * enc_play_toserver_update_jigsaw_block(char * dest, play_toserver_update_jigsaw_block source) {
  dest = enc_position(dest, source.location);
  dest = enc_string(dest, source.attachment_type);
  dest = enc_string(dest, source.target_pool);
  dest = enc_string(dest, source.final_state);
  return dest;
}

void free_play_toserver_update_jigsaw_block(play_toserver_update_jigsaw_block packet) {
  free_string(packet.attachment_type);
  free_string(packet.target_pool);
  free_string(packet.final_state);
}

int walk_play_toserver_update_sign(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_update_sign(play_toserver_update_sign packet) {
  size_t size = 0;
  size += 8;
  size += size_string(packet.text1);
  size += size_string(packet.text2);
  size += size_string(packet.text3);
  size += size_string(packet.text4);
  return size;
}

char * dec_play_toserver_update_sign(play_toserver_update_sign *packet, char * source) {
  source = dec_position(&packet->location, source);
  if(!(source = dec_string(&packet->text1, source))) return NULL;
  if(!(source = dec_string(&packet->text2, source))) return NULL;
  if(!(source = dec_string(&packet->text3, source))) return NULL;
  if(!(source = dec_string(&packet->text4, source))) return NULL;
  return source;
}

char * enc_play_toserver_update_sign(char * dest, play_toserver_update_sign source) {
  dest = enc_position(dest, source.location);
  dest = enc_string(dest, source.text1);
  dest = enc_string(dest, source.text2);
  dest = enc_string(dest, source.text3);
  dest = enc_string(dest, source.text4);
  return dest;
}

void free_play_toserver_update_sign(play_toserver_update_sign packet) {
  free_string(packet.text1);
  free_string(packet.text2);
  free_string(packet.text3);
  free_string(packet.text4);
}

int walk_play_toserver_arm_animation(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_arm_animation(play_toserver_arm_animation packet) {
  size_t size = 0;
  size += size_varlong(packet.hand);
  return size;
}

char * dec_play_toserver_arm_animation(play_toserver_arm_animation *packet, char * source) {
  source = dec_varlong(&packet->hand, source);
  return source;
}

char * enc_play_toserver_arm_animation(char * dest, play_toserver_arm_animation source) {
  dest = enc_varlong(dest, source.hand);
  return dest;
}

int walk_play_toserver_spectate(char * source, size_t max_len) {
  if(max_len < 16) return -1;
  return 16;
}

size_t size_play_toserver_spectate(play_toserver_spectate packet) {
  return 16;
}

char * dec_play_toserver_spectate(play_toserver_spectate *packet, char * source) {
  source = dec_uuid(&packet->target, source);
  return source;
}

char * enc_play_toserver_spectate(char * dest, play_toserver_spectate source) {
  dest = enc_uuid(dest, source.target);
  return dest;
}

int walk_play_toserver_block_place(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 13) {
    return -1;
  }
  return size + 13;
}

size_t size_play_toserver_block_place(play_toserver_block_place packet) {
  size_t size = 0;
  size += size_varlong(packet.hand);
  size += 8;
  size += size_varlong(packet.direction);
  return size + 13;
}

char * dec_play_toserver_block_place(play_toserver_block_place *packet, char * source) {
  source = dec_varlong(&packet->hand, source);
  source = dec_position(&packet->location, source);
  source = dec_varlong(&packet->direction, source);
  source = dec_bef32(&packet->cursor_x, source);
  source = dec_bef32(&packet->cursor_y, source);
  source = dec_bef32(&packet->cursor_z, source);
  source = dec_byte(&packet->inside_block, source);
  return source;
}

char * enc_play_toserver_block_place(char * dest, play_toserver_block_place source) {
  dest = enc_varlong(dest, source.hand);
  dest = enc_position(dest, source.location);
  dest = enc_varlong(dest, source.direction);
  dest = enc_bef32(dest, source.cursor_x);
  dest = enc_bef32(dest, source.cursor_y);
  dest = enc_bef32(dest, source.cursor_z);
  dest = enc_byte(dest, source.inside_block);
  return dest;
}

int walk_play_toserver_use_item(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_use_item(play_toserver_use_item packet) {
  size_t size = 0;
  size += size_varlong(packet.hand);
  return size;
}

char * dec_play_toserver_use_item(play_toserver_use_item *packet, char * source) {
  source = dec_varlong(&packet->hand, source);
  return source;
}

char * enc_play_toserver_use_item(char * dest, play_toserver_use_item source) {
  dest = enc_varlong(dest, source.hand);
  return dest;
}

int walk_play_toserver_advancement_tab(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t action;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&action, source);
  switch(action) {
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
    case 1:
      // void condition
      break;
  }
  return size;
}

size_t size_play_toserver_advancement_tab(play_toserver_advancement_tab packet) {
  size_t size = 0;
  size += size_varlong(packet.action);
  switch(packet.action) {
    case 0:
      size += size_string(packet.tab_id);
      break;
    case 1:
      // void condition
      break;
  }
  return size;
}

char * dec_play_toserver_advancement_tab(play_toserver_advancement_tab *packet, char * source) {
  source = dec_varlong(&packet->action, source);
  switch(packet->action) {
    case 0:
      if(!(source = dec_string(&packet->tab_id, source))) return NULL;
      break;
    case 1:
      // void condition
      break;
  }
  return source;
}

char * enc_play_toserver_advancement_tab(char * dest, play_toserver_advancement_tab source) {
  dest = enc_varlong(dest, source.action);
  switch(source.action) {
    case 0:
      dest = enc_string(dest, source.tab_id);
      break;
    case 1:
      // void condition
      break;
  }
  return dest;
}

void free_play_toserver_advancement_tab(play_toserver_advancement_tab packet) {
  switch(packet.action) {
    case 0:
      free_string(packet.tab_id);
      break;
    case 1:
      // No free-able types
      break;
  }
}

void * generic_toclient_decode(int state, int32_t id, char * src, size_t len) {
  void * dest;
  switch(state) {
    case status_id:
      switch(id) {
        case status_toclient_server_info_id:
          if(walk_status_toclient_server_info(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(status_toclient_server_info)))) return NULL;
          dec_status_toclient_server_info(dest, src);
          break;
        case status_toclient_ping_id:
          if(walk_status_toclient_ping(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(status_toclient_ping)))) return NULL;
          dec_status_toclient_ping(dest, src);
          break;
        default:
          return NULL;
      }
      break;
    case login_id:
      switch(id) {
        case login_toclient_disconnect_id:
          if(walk_login_toclient_disconnect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(login_toclient_disconnect)))) return NULL;
          dec_login_toclient_disconnect(dest, src);
          break;
        case login_toclient_encryption_begin_id:
          if(walk_login_toclient_encryption_begin(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(login_toclient_encryption_begin)))) return NULL;
          dec_login_toclient_encryption_begin(dest, src);
          break;
        case login_toclient_success_id:
          if(walk_login_toclient_success(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(login_toclient_success)))) return NULL;
          dec_login_toclient_success(dest, src);
          break;
        case login_toclient_compress_id:
          if(walk_login_toclient_compress(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(login_toclient_compress)))) return NULL;
          dec_login_toclient_compress(dest, src);
          break;
        case login_toclient_login_plugin_request_id:
          if(walk_login_toclient_login_plugin_request(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(login_toclient_login_plugin_request)))) return NULL;
          dec_login_toclient_login_plugin_request(dest, src);
          break;
        default:
          return NULL;
      }
      break;
    case play_id:
      switch(id) {
        case play_toclient_spawn_entity_id:
          if(walk_play_toclient_spawn_entity(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_entity)))) return NULL;
          dec_play_toclient_spawn_entity(dest, src);
          break;
        case play_toclient_spawn_entity_experience_orb_id:
          if(walk_play_toclient_spawn_entity_experience_orb(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_entity_experience_orb)))) return NULL;
          dec_play_toclient_spawn_entity_experience_orb(dest, src);
          break;
        case play_toclient_spawn_entity_weather_id:
          if(walk_play_toclient_spawn_entity_weather(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_entity_weather)))) return NULL;
          dec_play_toclient_spawn_entity_weather(dest, src);
          break;
        case play_toclient_spawn_entity_living_id:
          if(walk_play_toclient_spawn_entity_living(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_entity_living)))) return NULL;
          dec_play_toclient_spawn_entity_living(dest, src);
          break;
        case play_toclient_spawn_entity_painting_id:
          if(walk_play_toclient_spawn_entity_painting(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_entity_painting)))) return NULL;
          dec_play_toclient_spawn_entity_painting(dest, src);
          break;
        case play_toclient_named_entity_spawn_id:
          if(walk_play_toclient_named_entity_spawn(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_named_entity_spawn)))) return NULL;
          dec_play_toclient_named_entity_spawn(dest, src);
          break;
        case play_toclient_animation_id:
          if(walk_play_toclient_animation(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_animation)))) return NULL;
          dec_play_toclient_animation(dest, src);
          break;
        case play_toclient_statistics_id:
          if(walk_play_toclient_statistics(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_statistics)))) return NULL;
          dec_play_toclient_statistics(dest, src);
          break;
        case play_toclient_advancements_id:
          if(walk_play_toclient_advancements(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_advancements)))) return NULL;
          dec_play_toclient_advancements(dest, src);
          break;
        case play_toclient_block_break_animation_id:
          if(walk_play_toclient_block_break_animation(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_block_break_animation)))) return NULL;
          dec_play_toclient_block_break_animation(dest, src);
          break;
        case play_toclient_tile_entity_data_id:
          if(walk_play_toclient_tile_entity_data(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_tile_entity_data)))) return NULL;
          dec_play_toclient_tile_entity_data(dest, src);
          break;
        case play_toclient_block_action_id:
          if(walk_play_toclient_block_action(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_block_action)))) return NULL;
          dec_play_toclient_block_action(dest, src);
          break;
        case play_toclient_block_change_id:
          if(walk_play_toclient_block_change(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_block_change)))) return NULL;
          dec_play_toclient_block_change(dest, src);
          break;
        case play_toclient_boss_bar_id:
          if(walk_play_toclient_boss_bar(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_boss_bar)))) return NULL;
          dec_play_toclient_boss_bar(dest, src);
          break;
        case play_toclient_difficulty_id:
          if(walk_play_toclient_difficulty(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_difficulty)))) return NULL;
          dec_play_toclient_difficulty(dest, src);
          break;
        case play_toclient_tab_complete_id:
          if(walk_play_toclient_tab_complete(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_tab_complete)))) return NULL;
          dec_play_toclient_tab_complete(dest, src);
          break;
        case play_toclient_declare_commands_id:
          if(walk_play_toclient_declare_commands(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_declare_commands)))) return NULL;
          dec_play_toclient_declare_commands(dest, src);
          break;
        case play_toclient_face_player_id:
          if(walk_play_toclient_face_player(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_face_player)))) return NULL;
          dec_play_toclient_face_player(dest, src);
          break;
        case play_toclient_nbt_query_response_id:
          if(walk_play_toclient_nbt_query_response(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_nbt_query_response)))) return NULL;
          dec_play_toclient_nbt_query_response(dest, src);
          break;
        case play_toclient_chat_id:
          if(walk_play_toclient_chat(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_chat)))) return NULL;
          dec_play_toclient_chat(dest, src);
          break;
        case play_toclient_multi_block_change_id:
          if(walk_play_toclient_multi_block_change(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_multi_block_change)))) return NULL;
          dec_play_toclient_multi_block_change(dest, src);
          break;
        case play_toclient_transaction_id:
          if(walk_play_toclient_transaction(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_transaction)))) return NULL;
          dec_play_toclient_transaction(dest, src);
          break;
        case play_toclient_close_window_id:
          if(walk_play_toclient_close_window(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_close_window)))) return NULL;
          dec_play_toclient_close_window(dest, src);
          break;
        case play_toclient_open_window_id:
          if(walk_play_toclient_open_window(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_open_window)))) return NULL;
          dec_play_toclient_open_window(dest, src);
          break;
        case play_toclient_window_items_id:
          if(walk_play_toclient_window_items(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_window_items)))) return NULL;
          dec_play_toclient_window_items(dest, src);
          break;
        case play_toclient_craft_progress_bar_id:
          if(walk_play_toclient_craft_progress_bar(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_craft_progress_bar)))) return NULL;
          dec_play_toclient_craft_progress_bar(dest, src);
          break;
        case play_toclient_set_slot_id:
          if(walk_play_toclient_set_slot(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_set_slot)))) return NULL;
          dec_play_toclient_set_slot(dest, src);
          break;
        case play_toclient_set_cooldown_id:
          if(walk_play_toclient_set_cooldown(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_set_cooldown)))) return NULL;
          dec_play_toclient_set_cooldown(dest, src);
          break;
        case play_toclient_custom_payload_id:
          if(walk_play_toclient_custom_payload(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_custom_payload)))) return NULL;
          dec_play_toclient_custom_payload(dest, src, len);
          break;
        case play_toclient_named_sound_effect_id:
          if(walk_play_toclient_named_sound_effect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_named_sound_effect)))) return NULL;
          dec_play_toclient_named_sound_effect(dest, src);
          break;
        case play_toclient_kick_disconnect_id:
          if(walk_play_toclient_kick_disconnect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_kick_disconnect)))) return NULL;
          dec_play_toclient_kick_disconnect(dest, src);
          break;
        case play_toclient_entity_status_id:
          if(walk_play_toclient_entity_status(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_status)))) return NULL;
          dec_play_toclient_entity_status(dest, src);
          break;
        case play_toclient_explosion_id:
          if(walk_play_toclient_explosion(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_explosion)))) return NULL;
          dec_play_toclient_explosion(dest, src);
          break;
        case play_toclient_unload_chunk_id:
          if(walk_play_toclient_unload_chunk(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_unload_chunk)))) return NULL;
          dec_play_toclient_unload_chunk(dest, src);
          break;
        case play_toclient_game_state_change_id:
          if(walk_play_toclient_game_state_change(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_game_state_change)))) return NULL;
          dec_play_toclient_game_state_change(dest, src);
          break;
        case play_toclient_open_horse_window_id:
          if(walk_play_toclient_open_horse_window(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_open_horse_window)))) return NULL;
          dec_play_toclient_open_horse_window(dest, src);
          break;
        case play_toclient_keep_alive_id:
          if(walk_play_toclient_keep_alive(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_keep_alive)))) return NULL;
          dec_play_toclient_keep_alive(dest, src);
          break;
        case play_toclient_map_chunk_id:
          if(walk_play_toclient_map_chunk(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_map_chunk)))) return NULL;
          dec_play_toclient_map_chunk(dest, src);
          break;
        case play_toclient_world_event_id:
          if(walk_play_toclient_world_event(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_world_event)))) return NULL;
          dec_play_toclient_world_event(dest, src);
          break;
        case play_toclient_world_particles_id:
          if(walk_play_toclient_world_particles(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_world_particles)))) return NULL;
          dec_play_toclient_world_particles(dest, src);
          break;
        case play_toclient_update_light_id:
          if(walk_play_toclient_update_light(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_update_light)))) return NULL;
          dec_play_toclient_update_light(dest, src, len);
          break;
        case play_toclient_login_id:
          if(walk_play_toclient_login(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_login)))) return NULL;
          dec_play_toclient_login(dest, src);
          break;
        case play_toclient_map_id:
          if(walk_play_toclient_map(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_map)))) return NULL;
          dec_play_toclient_map(dest, src);
          break;
        case play_toclient_trade_list_id:
          if(walk_play_toclient_trade_list(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_trade_list)))) return NULL;
          dec_play_toclient_trade_list(dest, src);
          break;
        case play_toclient_rel_entity_move_id:
          if(walk_play_toclient_rel_entity_move(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_rel_entity_move)))) return NULL;
          dec_play_toclient_rel_entity_move(dest, src);
          break;
        case play_toclient_entity_move_look_id:
          if(walk_play_toclient_entity_move_look(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_move_look)))) return NULL;
          dec_play_toclient_entity_move_look(dest, src);
          break;
        case play_toclient_entity_look_id:
          if(walk_play_toclient_entity_look(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_look)))) return NULL;
          dec_play_toclient_entity_look(dest, src);
          break;
        case play_toclient_entity_id:
          if(walk_play_toclient_entity(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity)))) return NULL;
          dec_play_toclient_entity(dest, src);
          break;
        case play_toclient_vehicle_move_id:
          if(walk_play_toclient_vehicle_move(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_vehicle_move)))) return NULL;
          dec_play_toclient_vehicle_move(dest, src);
          break;
        case play_toclient_open_book_id:
          if(walk_play_toclient_open_book(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_open_book)))) return NULL;
          dec_play_toclient_open_book(dest, src);
          break;
        case play_toclient_open_sign_entity_id:
          if(walk_play_toclient_open_sign_entity(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_open_sign_entity)))) return NULL;
          dec_play_toclient_open_sign_entity(dest, src);
          break;
        case play_toclient_craft_recipe_response_id:
          if(walk_play_toclient_craft_recipe_response(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_craft_recipe_response)))) return NULL;
          dec_play_toclient_craft_recipe_response(dest, src);
          break;
        case play_toclient_abilities_id:
          if(walk_play_toclient_abilities(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_abilities)))) return NULL;
          dec_play_toclient_abilities(dest, src);
          break;
        case play_toclient_combat_event_id:
          if(walk_play_toclient_combat_event(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_combat_event)))) return NULL;
          dec_play_toclient_combat_event(dest, src);
          break;
        case play_toclient_player_info_id:
          if(walk_play_toclient_player_info(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_player_info)))) return NULL;
          dec_play_toclient_player_info(dest, src);
          break;
        case play_toclient_position_id:
          if(walk_play_toclient_position(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_position)))) return NULL;
          dec_play_toclient_position(dest, src);
          break;
        case play_toclient_unlock_recipes_id:
          if(walk_play_toclient_unlock_recipes(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_unlock_recipes)))) return NULL;
          dec_play_toclient_unlock_recipes(dest, src);
          break;
        case play_toclient_entity_destroy_id:
          if(walk_play_toclient_entity_destroy(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_destroy)))) return NULL;
          dec_play_toclient_entity_destroy(dest, src);
          break;
        case play_toclient_remove_entity_effect_id:
          if(walk_play_toclient_remove_entity_effect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_remove_entity_effect)))) return NULL;
          dec_play_toclient_remove_entity_effect(dest, src);
          break;
        case play_toclient_resource_pack_send_id:
          if(walk_play_toclient_resource_pack_send(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_resource_pack_send)))) return NULL;
          dec_play_toclient_resource_pack_send(dest, src);
          break;
        case play_toclient_respawn_id:
          if(walk_play_toclient_respawn(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_respawn)))) return NULL;
          dec_play_toclient_respawn(dest, src);
          break;
        case play_toclient_entity_update_attributes_id:
          if(walk_play_toclient_entity_update_attributes(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_update_attributes)))) return NULL;
          dec_play_toclient_entity_update_attributes(dest, src);
          break;
        case play_toclient_world_border_id:
          if(walk_play_toclient_world_border(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_world_border)))) return NULL;
          dec_play_toclient_world_border(dest, src);
          break;
        case play_toclient_camera_id:
          if(walk_play_toclient_camera(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_camera)))) return NULL;
          dec_play_toclient_camera(dest, src);
          break;
        case play_toclient_held_item_slot_id:
          if(walk_play_toclient_held_item_slot(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_held_item_slot)))) return NULL;
          dec_play_toclient_held_item_slot(dest, src);
          break;
        case play_toclient_update_view_position_id:
          if(walk_play_toclient_update_view_position(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_update_view_position)))) return NULL;
          dec_play_toclient_update_view_position(dest, src);
          break;
        case play_toclient_update_view_distance_id:
          if(walk_play_toclient_update_view_distance(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_update_view_distance)))) return NULL;
          dec_play_toclient_update_view_distance(dest, src);
          break;
        case play_toclient_scoreboard_display_objective_id:
          if(walk_play_toclient_scoreboard_display_objective(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_scoreboard_display_objective)))) return NULL;
          dec_play_toclient_scoreboard_display_objective(dest, src);
          break;
        case play_toclient_entity_metadata_id:
          if(walk_play_toclient_entity_metadata(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_metadata)))) return NULL;
          dec_play_toclient_entity_metadata(dest, src);
          break;
        case play_toclient_attach_entity_id:
          if(walk_play_toclient_attach_entity(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_attach_entity)))) return NULL;
          dec_play_toclient_attach_entity(dest, src);
          break;
        case play_toclient_entity_velocity_id:
          if(walk_play_toclient_entity_velocity(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_velocity)))) return NULL;
          dec_play_toclient_entity_velocity(dest, src);
          break;
        case play_toclient_entity_equipment_id:
          if(walk_play_toclient_entity_equipment(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_equipment)))) return NULL;
          dec_play_toclient_entity_equipment(dest, src);
          break;
        case play_toclient_experience_id:
          if(walk_play_toclient_experience(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_experience)))) return NULL;
          dec_play_toclient_experience(dest, src);
          break;
        case play_toclient_update_health_id:
          if(walk_play_toclient_update_health(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_update_health)))) return NULL;
          dec_play_toclient_update_health(dest, src);
          break;
        case play_toclient_scoreboard_objective_id:
          if(walk_play_toclient_scoreboard_objective(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_scoreboard_objective)))) return NULL;
          dec_play_toclient_scoreboard_objective(dest, src);
          break;
        case play_toclient_set_passengers_id:
          if(walk_play_toclient_set_passengers(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_set_passengers)))) return NULL;
          dec_play_toclient_set_passengers(dest, src);
          break;
        case play_toclient_teams_id:
          if(walk_play_toclient_teams(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_teams)))) return NULL;
          dec_play_toclient_teams(dest, src);
          break;
        case play_toclient_scoreboard_score_id:
          if(walk_play_toclient_scoreboard_score(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_scoreboard_score)))) return NULL;
          dec_play_toclient_scoreboard_score(dest, src);
          break;
        case play_toclient_spawn_position_id:
          if(walk_play_toclient_spawn_position(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_position)))) return NULL;
          dec_play_toclient_spawn_position(dest, src);
          break;
        case play_toclient_update_time_id:
          if(walk_play_toclient_update_time(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_update_time)))) return NULL;
          dec_play_toclient_update_time(dest, src);
          break;
        case play_toclient_title_id:
          if(walk_play_toclient_title(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_title)))) return NULL;
          dec_play_toclient_title(dest, src);
          break;
        case play_toclient_entity_sound_effect_id:
          if(walk_play_toclient_entity_sound_effect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_sound_effect)))) return NULL;
          dec_play_toclient_entity_sound_effect(dest, src);
          break;
        case play_toclient_stop_sound_id:
          if(walk_play_toclient_stop_sound(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_stop_sound)))) return NULL;
          dec_play_toclient_stop_sound(dest, src);
          break;
        case play_toclient_sound_effect_id:
          if(walk_play_toclient_sound_effect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_sound_effect)))) return NULL;
          dec_play_toclient_sound_effect(dest, src);
          break;
        case play_toclient_playerlist_header_id:
          if(walk_play_toclient_playerlist_header(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_playerlist_header)))) return NULL;
          dec_play_toclient_playerlist_header(dest, src);
          break;
        case play_toclient_collect_id:
          if(walk_play_toclient_collect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_collect)))) return NULL;
          dec_play_toclient_collect(dest, src);
          break;
        case play_toclient_entity_teleport_id:
          if(walk_play_toclient_entity_teleport(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_teleport)))) return NULL;
          dec_play_toclient_entity_teleport(dest, src);
          break;
        case play_toclient_entity_head_rotation_id:
          if(walk_play_toclient_entity_head_rotation(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_head_rotation)))) return NULL;
          dec_play_toclient_entity_head_rotation(dest, src);
          break;
        case play_toclient_entity_effect_id:
          if(walk_play_toclient_entity_effect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_effect)))) return NULL;
          dec_play_toclient_entity_effect(dest, src);
          break;
        case play_toclient_select_advancement_tab_id:
          if(walk_play_toclient_select_advancement_tab(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_select_advancement_tab)))) return NULL;
          dec_play_toclient_select_advancement_tab(dest, src);
          break;
        case play_toclient_declare_recipes_id:
          if(walk_play_toclient_declare_recipes(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_declare_recipes)))) return NULL;
          dec_play_toclient_declare_recipes(dest, src);
          break;
        case play_toclient_tags_id:
          if(walk_play_toclient_tags(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_tags)))) return NULL;
          dec_play_toclient_tags(dest, src);
          break;
        case play_toclient_acknowledge_player_digging_id:
          if(walk_play_toclient_acknowledge_player_digging(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_acknowledge_player_digging)))) return NULL;
          dec_play_toclient_acknowledge_player_digging(dest, src);
          break;
        default:
          return NULL;
      }
      break;
    default:
      return NULL;
  }
  return dest;
}
